#algorithms #graphTraversal #dataStructures #searchAlgorithms #pathFinding

# Алгоритмы поиска в графах: DFS и BFS

```table-of-contents
```

## Обзор алгоритмов поиска в графах

DFS (Depth-First Search, поиск в глубину) и BFS (Breadth-First Search, поиск в ширину) представляют собой фундаментальные алгоритмы обхода графов, которые используются для решения широкого спектра задач в информатике и программировании.

## Поиск в глубину (DFS)

DFS исследует граф, двигаясь вглубь по каждой ветви, прежде чем возвращаться назад. Алгоритм начинает с корневого узла (или произвольного узла в случае несвязного графа) и исследует максимально далеко каждый путь, прежде чем возвращаться.

### Принцип работы DFS

1. Начать с выбранной вершины и пометить её как посещённую
2. Исследовать все смежные непосещённые вершины рекурсивно
3. Если все смежные вершины уже посещены, возвращаться назад

### Реализация DFS на Go

```go
func DFS(graph map[string][]string, startVertex string) {
    visited := make(map[string]bool)
    dfsUtil(graph, startVertex, visited)
}

func dfsUtil(graph map[string][]string, vertex string, visited map[string]bool) {
    // Помечаем текущую вершину как посещённую
    visited[vertex] = true
    fmt.Println("Посещена вершина:", vertex)
    
    // Рекурсивно обходим все смежные вершины
    for _, neighbor := range graph[vertex] {
        if !visited[neighbor] {
            dfsUtil(graph, neighbor, visited)
        }
    }
}
```

### Применения DFS

- Топологическая сортировка
- Поиск компонент связности
- Обнаружение циклов в графе
- Построение минимального остовного дерева (алгоритм Тарьяна)
- Решение головоломок и лабиринтов

## Поиск в ширину (BFS)

BFS исследует граф слой за слоем, посещая все вершины на одном уровне удаления от начальной вершины, прежде чем переходить к вершинам следующего уровня.

### Принцип работы BFS

1. Начать с выбранной вершины и поместить её в очередь
2. Извлечь вершину из очереди, пометить её как посещённую
3. Добавить все непосещённые смежные вершины в очередь
4. Повторять, пока очередь не опустеет

### Реализация BFS на Go

```go
func BFS(graph map[string][]string, startVertex string) {
    visited := make(map[string]bool)
    queue := []string{startVertex}
    visited[startVertex] = true
    
    for len(queue) > 0 {
        // Извлекаем вершину из начала очереди
        vertex := queue[0]
        queue = queue[1:]
        fmt.Println("Посещена вершина:", vertex)
        
        // Добавляем все непосещённые смежные вершины в очередь
        for _, neighbor := range graph[vertex] {
            if !visited[neighbor] {
                visited[neighbor] = true
                queue = append(queue, neighbor)
            }
        }
    }
}
```

### Применения BFS

- Нахождение кратчайшего пути в невзвешенном графе
- Тестирование двудольности графа
- Определение всех узлов в пределах определённого расстояния
- Алгоритм Эдмондса-Карпа для поиска максимального потока
- Сериализация/десериализация двоичного дерева

## Сравнение DFS и BFS

| Характеристика | DFS | BFS |
|----------------|-----|-----|
| Структура данных | Стек (неявный при рекурсии) | Очередь |
| Порядок обхода | Вглубь, затем вширь | Вширь, затем вглубь |
| Память | $O(h)$, где $h$ - высота графа | $O(w)$, где $w$ - максимальная ширина графа |
| Поиск кратчайшего пути | Не гарантирует в общем случае | Гарантирует в невзвешенном графе |
| Бесконечные графы | Может не завершиться | Найдёт решение, если оно существует |

## Взвешенные графы и поиск кратчайшего пути

Взвешенный граф — это граф, в котором каждому ребру присвоено числовое значение (вес), представляющее определённую характеристику соединения между вершинами: расстояние, стоимость, пропускную способность и т.д.

### Особенности поиска в взвешенных графах

В отличие от утверждения в старой версии, ни DFS, ни BFS сами по себе не гарантируют нахождение кратчайшего пути во взвешенном графе. BFS находит кратчайший путь только в невзвешенных графах или графах с одинаковыми весами рёбер.

Для нахождения кратчайшего пути во взвешенном графе используются специализированные алгоритмы:

### Алгоритм Дейкстры

Алгоритм Дейкстры находит кратчайшие пути от одной вершины до всех остальных в графе с неотрицательными весами рёбер.

```go
func Dijkstra(graph map[string]map[string]int, start string) map[string]int {
    distances := make(map[string]int)
    visited := make(map[string]bool)
    
    // Инициализируем расстояния как "бесконечность"
    for vertex := range graph {
        distances[vertex] = math.MaxInt32
    }
    distances[start] = 0
    
    for len(visited) < len(graph) {
        // Находим вершину с минимальным расстоянием среди непосещённых
        minVertex := ""
        minDistance := math.MaxInt32
        
        for vertex, distance := range distances {
            if !visited[vertex] && distance < minDistance {
                minVertex = vertex
                minDistance = distance
            }
        }
        
        if minVertex == "" {
            break // Все достижимые вершины уже посещены
        }
        
        visited[minVertex] = true
        
        // Обновляем расстояния до соседей
        for neighbor, weight := range graph[minVertex] {
            if newDistance := distances[minVertex] + weight; newDistance < distances[neighbor] {
                distances[neighbor] = newDistance
            }
        }
    }
    
    return distances
}
```

### Алгоритм Беллмана-Форда

Алгоритм Беллмана-Форда находит кратчайшие пути от одной вершины до всех остальных даже в графах с отрицательными весами рёбер, при условии отсутствия отрицательных циклов.

### Алгоритм Флойда-Уоршелла

Алгоритм Флойда-Уоршелла находит кратчайшие пути между всеми парами вершин в графе, в том числе с отрицательными весами, но без отрицательных циклов.

```go
func FloydWarshall(graph [][]int) [][]int {
    n := len(graph)
    dist := make([][]int, n)
    
    // Инициализируем матрицу расстояний
    for i := 0; i < n; i++ {
        dist[i] = make([]int, n)
        for j := 0; j < n; j++ {
            dist[i][j] = graph[i][j]
        }
    }
    
    // Алгоритм Флойда-Уоршелла
    for k := 0; k < n; k++ {
        for i := 0; i < n; i++ {
            for j := 0; j < n; j++ {
                if dist[i][k] != math.MaxInt32 && dist[k][j] != math.MaxInt32 &&
                   dist[i][k]+dist[k][j] < dist[i][j] {
                    dist[i][j] = dist[i][k] + dist[k][j]
                }
            }
        }
    }
    
    return dist
}
```

## Модификации базовых алгоритмов

Существуют различные модификации DFS и BFS для решения специфических задач:

- **Двунаправленный поиск**: одновременно запускает поиск от начальной и конечной вершин, что может значительно ускорить нахождение пути
- **A*** (A-star): улучшение алгоритма Дейкстры с использованием эвристики для направления поиска
- **Итеративное углубление DFS**: сочетает преимущества DFS и BFS, используя ограничение глубины
- **Bidirectional A***: комбинация двунаправленного поиска и алгоритма A*

## Заключение

DFS и BFS являются базовыми алгоритмами обхода графов с различными характеристиками и областями применения. Для невзвешенных графов BFS гарантирует нахождение кратчайшего пути, в то время как для взвешенных графов требуются более специализированные алгоритмы, такие как Дейкстра, Беллман-Форд или Флойд-Уоршелл. Выбор алгоритма зависит от конкретной задачи, структуры графа и требований к эффективности.


>[!quote] Старая версия
```
	## DFS/BFS
	
	DFS (Depth-First Search) и BFS (Breadth-First Search) - это два алгоритма поиска в графе. DFS ищет в глубину, переходя на каждый уровень графа, пока не будет найден целевой узел или не будут исследованы все узлы. BFS ищет в ширину, посещая все узлы на одном уровне перед переходом к узлам следующего уровня. Оба алгоритма могут быть использованы для поиска кратчайшего пути в невзвешенном графе, но только BFS может быть использован для этой цели во взвешенном графе.
	
	Взвешенный граф - это граф, в котором каждому ребру присвоено некоторое числовое значение, называемое весом. Вес может отражать, например, расстояние между двумя вершинами, стоимость перехода от одной вершины к другой и т.д. Взвешенный граф используется для решения задач, связанных с оптимизацией и нахождением кратчайшего пути между вершинами. Для поиска кратчайшего пути в взвешенном графе обычно используется алгоритм Дейкстры или алгоритм Флойда-Уоршелла.
```

