#dataStructures #heap #golang #algorithms #priorityQueue

# Куча (Heap) в Go

```table-of-contents
```

## Определение и основные свойства

Куча (heap) — это специализированная древовидная структура данных, которая удовлетворяет свойству кучи: для любого узла значение этого узла находится в определенном отношении с значениями его дочерних узлов. Существует два основных типа куч:

- **Куча минимумов (Min Heap)**: значение каждого узла не больше значений его потомков
- **Куча максимумов (Max Heap)**: значение каждого узла не меньше значений его потомков

Куча обычно реализуется как полное бинарное дерево, что позволяет эффективно представлять его в виде массива без использования указателей.

## Интерфейс кучи в Go

В стандартной библиотеке Go куча представлена через интерфейс `heap.Interface` из пакета `container/heap`. Этот интерфейс расширяет `sort.Interface` и добавляет два метода для работы с кучей:

```go
// heap.go
type Interface interface {
    sort.Interface
    Push(x any) // добавляет x как элемент с индексом Len()
    Pop() any   // удаляет и возвращает элемент с индексом Len() - 1
}

// sort.go
type Interface interface {
    // Len возвращает количество элементов в коллекции
    Len() int
    
    // Less сообщает, должен ли элемент с индексом i
    // идти перед элементом с индексом j
    Less(i, j int) bool
    
    // Swap меняет местами элементы с индексами i и j
    Swap(i, j int)
}
```

## Визуальное представление

![Heap](./assets/heap.png)

На изображении справа показана куча минимумов (также называемая "Priority Queue"), где каждый узел имеет значение, которое не больше значений его потомков. В такой куче наименьший элемент всегда находится в корне дерева (в позиции 0 массива).

## Принцип работы кучи

Куча обычно реализуется как массив, где для элемента с индексом `i`:
- Левый потомок находится в позиции `2*i + 1`
- Правый потомок находится в позиции `2*i + 2`
- Родитель находится в позиции `(i-1)/2`

Эта упорядоченная структура позволяет эффективно выполнять основные операции:

### Основные операции

1. **Добавление элемента (Push)**: 
   - Добавляем элемент в конец массива
   - Выполняем операцию "всплытия" (sift-up), перемещая элемент вверх, пока не будет соблюдено свойство кучи

2. **Извлечение минимального/максимального элемента (Pop)**:
   - Сохраняем корневой элемент (индекс 0) как результат
   - Перемещаем последний элемент кучи на место корня
   - Выполняем операцию "просеивания" (sift-down), перемещая новый корень вниз, пока не будет соблюдено свойство кучи

3. **Исправление позиции элемента (Fix)**:
   - Используется, когда значение элемента изменилось
   - Выполняется либо "всплытие", либо "просеивание" в зависимости от того, как изменилось значение

4. **Удаление элемента (Remove)**:
   - Заменяем удаляемый элемент последним элементом кучи
   - Выполняем Fix для восстановления свойства кучи

## Пример реализации в Go

Рассмотрим пример реализации кучи минимумов для целых чисел:

```go
package main

import (
    "container/heap"
    "fmt"
)

// IntMinHeap - куча минимумов для целых чисел
type IntMinHeap []int

func (h IntMinHeap) Len() int           { return len(h) }
func (h IntMinHeap) Less(i, j int) bool { return h[i] < h[j] } // Для кучи максимумов используйте h[i] > h[j]
func (h IntMinHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

// Push добавляет элемент x в кучу
func (h *IntMinHeap) Push(x any) {
    *h = append(*h, x.(int))
}

// Pop удаляет и возвращает минимальный элемент
func (h *IntMinHeap) Pop() any {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}

func main() {
    h := &IntMinHeap{3, 1, 4, 1, 5, 9, 2, 6}
    heap.Init(h) // Преобразует массив в кучу, O(n)
    
    fmt.Printf("Минимальный элемент: %d\n", (*h)[0])
    
    heap.Push(h, 0) // Добавляем новый элемент
    fmt.Printf("После добавления 0, минимальный элемент: %d\n", (*h)[0])
    
    for h.Len() > 0 {
        fmt.Printf("%d ", heap.Pop(h))
    }
    fmt.Println()
}
```

## Сложность операций

- **Init**: O(n) - создание кучи из произвольного массива
- **Push**: O(log n) - добавление нового элемента
- **Pop**: O(log n) - удаление минимального/максимального элемента
- **Fix**: O(log n) - исправление позиции элемента
- **Remove**: O(log n) - удаление произвольного элемента

## Применение кучи

Куча является чрезвычайно полезной структурой данных для множества задач:

1. **Очередь с приоритетом**: элементы извлекаются в порядке их приоритета
2. **Алгоритм Дейкстры**: для поиска кратчайшего пути в графе
3. **Сортировка кучей (Heapsort)**: эффективный алгоритм сортировки с гарантированной сложностью O(n log n)
4. **Нахождение k наименьших/наибольших элементов**: путем последовательного извлечения элементов из кучи
5. **Медиана в потоке данных**: с использованием двух куч (минимумов и максимумов)
6. **Алгоритмы планирования процессов**: для определения следующего процесса для выполнения

## Расширенные операции с кучей

Пакет `container/heap` предоставляет несколько полезных функций для работы с кучами:

```go
// Инициализирует кучу из произвольного массива
func Init(h Interface)

// Добавляет элемент в кучу и восстанавливает свойство кучи
func Push(h Interface, x any)

// Удаляет и возвращает минимальный элемент кучи
func Pop(h Interface) any

// Исправляет позицию элемента с индексом i после изменения его значения
func Fix(h Interface, i int)

// Удаляет элемент с индексом i из кучи
func Remove(h Interface, i int) any
```

Эти функции позволяют эффективно работать с кучей в различных сценариях применения.


>[!quote] Старая версия
```
	## Heap
	
	Куча (heap) - это структура данных, которая упорядочивает элементы в виде двоичного дерева, при этом каждый узел имеет значение, которое не меньше (для кучи минимумов) или не больше (для кучи максимумов) значений его потомков. В GoLang куча представлена типом `heap.Interface`, который описывает методы, необходимые для работы с кучей:
	
	```go
	// heap.go
	type Interface interface {
		sort.Interface
		Push(x any) // add x as element Len()
		Pop() any   // remove and return element Len() - 1.
	}
	// sort.go
	type Interface interface {
		// Len is the number of elements in the collection.
		Len() int
	
		// Less reports whether the element with index i
		// must sort before the element with index j.
		//
		// If both Less(i, j) and Less(j, i) are false,
		// then the elements at index i and j are considered equal.
		// Sort may place equal elements in any order in the final result,
		// while Stable preserves the original input order of equal elements.
		//
		// Less must describe a transitive ordering:
		//  - if both Less(i, j) and Less(j, k) are true, then Less(i, k) must be true as well.
		//  - if both Less(i, j) and Less(j, k) are false, then Less(i, k) must be false as well.
		//
		// Note that floating-point comparison (the < operator on float32 or float64 values)
		// is not a transitive ordering when not-a-number (NaN) values are involved.
		// See Float64Slice.Less for a correct implementation for floating-point values.
		Less(i, j int) bool
	
		// Swap swaps the elements with indexes i and j.
		Swap(i, j int)
	}
	```
	
	![](./assets/heap.png)
	
	На картинке показано справа, как выглядит куча минимумов (i.e. "Priority Queue"), где каждый узел имеет значение, которое не меньше значений его потомков. В куче минимумов наименьший элемент всегда находится в корне дерева, что делает его полезным для решения ряда задач, таких как нахождение k наименьших элементов в списке или поиск медианы в потоке данных. Для работы с кучей можно использовать пакет `container/heap`, который предоставляет реализацию кучи минимумов и максимумов, а также методы для работы с ней, такие как `Push()`, `Pop()`, `Fix()`, `Remove()`, и другие.
	
	Добавление нового элемента в кучу выполняется путем помещения элемента в последнюю свободную позицию в массиве и затем "всплытия" его вверх по дереву, пока не будет найдена его правильная позиция. Удаление элемента с наименьшим (наибольшим) значением выполняется путем замены его последним элементом в массиве, после чего он "просеивается" вниз по дереву, пока не будет найдена его правильная позиция.
```

