#algorithms

Сбалансированным деревом называют особый тип двоичного дерева поиска, в котором автоматически поддерживается баланс между левым и правым поддеревьями для обеспечения оптимальной производительности операций.

## Основные характеристики:

**Сбалансированное дерево** — это дерево, где для любого узла высота левого и правого поддеревьев различается не более чем на определённую константу (обычно 1).

## Цель балансировки:

Главная цель — гарантировать, что **высота дерева остаётся O(log n)**, где n — количество элементов. Это обеспечивает эффективность всех основных операций:
- Поиск: O(log n)
- Вставка: O(log n) 
- Удаление: O(log n)

## Основные типы сбалансированных деревьев:

### 1. **AVL-деревья**
- Для каждого узла высоты левого и правого поддеревьев различаются максимум на 1
- Более строгая балансировка → быстрый поиск
- Более частые перебалансировки при вставке/удалении

### 2. **Красно-чёрные деревья**
- Каждый узел окрашен в красный или чёрный цвет
- Соблюдаются правила окраски для поддержания баланса
- Менее строгая балансировка → быстрее вставка/удаление
- Используются в `TreeSet` из моего предыдущего примера

### 3. **B-деревья**
- Узлы могут содержать несколько ключей
- Все листья находятся на одном уровне
- Часто используются в базах данных

### 4. **Splay-деревья**
- Самоорганизующиеся деревья
- Часто используемые элементы перемещаются ближе к корню

## Правила красно-чёрного дерева:

1. Каждый узел либо красный, либо чёрный
2. Корень всегда чёрный
3. Все листья (NIL) чёрные
4. Красный узел не может иметь красных детей
5. Любой путь от узла до листа содержит одинаковое количество чёрных узлов

## Операции балансировки:

При нарушении баланса выполняются **ротации**:

```
Левая ротация:
    x                 y
   / \               / \
  a   y      →      x   c
     / \           / \
    b   c         a   b

Правая ротация:
      y               x
     / \             / \
    x   c     →     a   y
   / \                 / \
  a   b               b   c
```

## Преимущества сбалансированных деревьев:

✅ **Гарантированная производительность** O(log n)  
✅ **Эффективное использование памяти**  
✅ **Поддержание порядка элементов**  
✅ **Динамическая структура** (эффективная вставка/удаление)

## Недостатки:

❌ **Сложность реализации** (особенно операции балансировки)  
❌ **Дополнительные накладные расходы** на поддержание баланса  
❌ **Больше памяти** для хранения метаинформации (цвета, высоты)

## Применение:

- **Базы данных** (индексы)
- **Операционные системы** (файловые системы)
- **Компиляторы** (таблицы символов)
- **Стандартные библиотеки** (map, set в различных языках)
- **Упорядоченные множества** (как в моём примере с TreeSet)

Сбалансированные деревья являются фундаментальной структурой данных, обеспечивающей эффективную работу с упорядоченными коллекциями данных в логарифмическое время.
