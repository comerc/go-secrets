#algorithms #binaryvector #go #sequenceanalysis #programming

# Поиск самой длинной последовательности единиц в бинарном векторе

```table-of-contents
```

## Условие задачи

Требуется найти в бинарном векторе самую длинную последовательность идущих подряд единиц и вывести её длину.

## Алгоритм решения

Для решения этой задачи можно использовать простой линейный проход по массиву с двумя счетчиками:
1. Счетчик текущей последовательности единиц
2. Счетчик максимальной найденной последовательности

При обходе массива:
- Если встречаем единицу, увеличиваем счетчик текущей последовательности
- Если встречаем ноль, обновляем максимальный счетчик (если текущая последовательность длиннее) и обнуляем текущий счетчик
- После завершения обхода, еще раз проверяем максимум (для случая, когда массив заканчивается единицами)

Алгоритм требует только $O(1)$ дополнительной памяти и $O(n)$ времени, где $n$ - длина входного массива.

## Реализация на Go

[[b|Последовательно идущие единицы]]

```go
package main

import (
	"fmt"
)

// findLongestOnesSequence находит длину самой длинной последовательности единиц
func findLongestOnesSequence(arr []int) int {
	maxLength := 0    // максимальная длина последовательности единиц
	currentLength := 0 // текущая длина последовательности единиц
	
	for _, num := range arr {
		if num == 1 {
			// Увеличиваем счетчик текущей последовательности
			currentLength++
			
			// Обновляем максимум, если текущая последовательность длиннее
			if currentLength > maxLength {
				maxLength = currentLength
			}
		} else {
			// Сбрасываем счетчик при встрече нуля
			currentLength = 0
		}
	}
	
	return maxLength
}

func main() {
	// Примеры для тестирования
	testCases := []struct {
		arr      []int
		expected int
	}{
		{[]int{1, 1, 0, 1, 1, 1, 0, 1}, 3},
		{[]int{0, 0, 0, 0}, 0},
		{[]int{1, 1, 1, 1}, 4},
		{[]int{0, 1, 1, 0, 1, 1, 1, 1, 0}, 4},
		{[]int{1, 0, 1, 1, 1, 0, 1, 1, 1, 1}, 4},
		{[]int{0, 1, 1, 1, 0, 1, 1, 1, 1, 1}, 5},
	}
	
	for i, tc := range testCases {
		result := findLongestOnesSequence(tc.arr)
		fmt.Printf("Тест %d: %v -> %d (ожидалось: %d)\n", i+1, tc.arr, result, tc.expected)
		
		if result != tc.expected {
			fmt.Printf("ОШИБКА в тесте %d!\n", i+1)
		}
	}
}
```

## Особенности реализации

Обратите внимание на следующие детали:

1. **Обработка последовательности в конце массива**: Алгоритм корректно обрабатывает случай, когда массив заканчивается единицами, поскольку максимальная длина обновляется внутри цикла при каждом увеличении текущей длины.

2. **Константная дополнительная память**: Используются только две переменные (`maxLength` и `currentLength`), независимо от размера входного массива, что соответствует требованию использовать константный объем дополнительной памяти.

3. **Обработка пустого массива**: Если входной массив пуст, функция вернет 0, что логично, так как в пустом массиве нет последовательностей.

4. **Обработка массива, состоящего только из нулей**: Если в массиве нет единиц, функция вернет 0.

5. **Обработка массива, состоящего только из единиц**: В этом случае максимальная длина будет равна длине всего массива.

Данный алгоритм является оптимальным для решения поставленной задачи как по времени, так и по памяти.


>[!quote] Старая версия
```
	### Задача B. Последовательно идущие единицы
	
> 	Требуется найти в бинарном векторе самую длинную последовательность единиц и вывести её длину.
	
	Алгоритм решения следующий: пройтись по всем элементам массива; встретив единицу, нужно увеличить счётчик длины текущей последовательности, а, встретив ноль, нужно обнулить этот счётчик. В конце нужно вывести максимальное из значений, которые принимал счётчик.
	
	Проверьте, что правильно обрабатываете ситуацию, когда массив заканчивается на искомую последовательность единиц. При аккуратной реализации такая ситуация не потребует специальной обработки.
	
	Постарайтесь использовать лишь константный объём дополнительной памяти.
```
