#runtimeMemstats #go #memory #allocation #garbageCollection #profiling #optimization #slice #memoryLeak #runtime

# Изучение поведения `runtime.GC()` с помощью `runtime.Memstats`

```table-of-contents
```

## Введение

В Go управление памятью осуществляется автоматически с помощью сборщика мусора ([[Garbage Collector, GC]]). `runtime.MemStats` предоставляет подробную статистику о состоянии распределителя памяти, что позволяет анализировать и оптимизировать использование памяти в приложениях. В частности, можно отслеживать количество выделенной памяти в куче ([[Heap]]). Функция `runtime.GC()` принудительно запускает сборку мусора, что, в сочетании с `runtime.MemStats`, позволяет наблюдать за поведением сборщика мусора.

## Анализ предоставленного кода

Рассмотрим предоставленный код построчно, чтобы понять, как он демонстрирует взаимодействие `runtime.MemStats` и `runtime.GC()`.

**1. Структура `Foo` и инициализация:**

```go
type Foo struct {
	v []byte
}

func main() {
	foos := make([]Foo, 1_000)
	printAlloc()
```

Определяется структура `Foo`, содержащая срез байтов `v`.  Создается срез `foos` из 1000 элементов типа `Foo`. Вызов `printAlloc()` выводит начальное использование памяти.

**2. `printAlloc()`:**

```go
func printAlloc() {
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	fmt.Printf("%d KB\n", m.Alloc/1024)
}
```

Эта функция считывает статистику памяти с помощью `runtime.ReadMemStats(&m)`, где `m` — переменная типа `runtime.MemStats`. Затем она выводит значение `m.Alloc`, представляющее собой общее количество байтов, выделенных в куче, деленное на 1024 для отображения в килобайтах.

**3. Выделение памяти в цикле:**

```go
	for i := 0; i < len(foos); i++ {
		foos[i] = Foo{
			v: make([]byte, 1024*1024),
		}
	}
	printAlloc()
```

В цикле каждому элементу среза `foos` присваивается новый экземпляр `Foo`, причем поле `v` инициализируется срезом байтов размером 1 МБ (1024 * 1024 байт). После этого снова вызывается `printAlloc()`, чтобы показать увеличение использования памяти.

**4. Функция `keepFirstTwoElementsOnly()` и утечка памяти:**

```go
func keepFirstTwoElementsOnly(foos []Foo) []Foo {
  // утечка
  return foos[:2]
  // решение с расходом mem
	// res := make([]Foo, 2)
	// copy(res, foos)
	// return res
  // решение с расходом cpu
	// for i := 2; i < len(foos); i++ {
	// 	foos[i].v = nil
	// }
	// return foos[:2]
}
```

Эта функция предназначена для возврата нового среза, содержащего только первые два элемента исходного среза `foos`.  Однако, в текущей реализации (`return foos[:2]`) возникает утечка памяти.  В Go срезы являются представлениями базовых массивов.  Когда мы создаем под-срез `foos[:2]`, он по-прежнему ссылается на *исходный* массив, содержащий 1000 элементов `Foo`.  Даже если мы больше не используем оставшиеся 998 элементов, сборщик мусора не может их освободить, потому что на базовый массив все еще есть ссылка.

В коде закомментированы два альтернативных решения, которые решают эту проблему:

*   **Решение с расходом памяти:** Создается новый срез нужной длины (`res := make([]Foo, 2)`), и в него копируются нужные элементы (`copy(res, foos)`). Это самое идиоматичное решение в Go.
*   **Решение с расходом CPU:**  В цикле обнуляются ссылки на срезы байтов (`v`) для всех элементов, кроме первых двух (`foos[i].v = nil`). Это позволяет сборщику мусора освободить память, выделенную для этих срезов.  Это менее эффективно, чем копирование, из-за накладных расходов на цикл.

**5. Вызов `runtime.GC()` и `runtime.KeepAlive()`:**

```go
	two := keepFirstTwoElementsOnly(foos)
	runtime.GC()           // Вызывается GC, чтобы принудительно вызвать очистку кучи printAlloc()
	runtime.KeepAlive(two) // Сохраняется ссылка на переменную two
	printAlloc()
}
```

Сначала вызывается функция `keepFirstTwoElementsOnly()`, создающая утечку памяти. Затем явно вызывается сборщик мусора с помощью `runtime.GC()`.  Это *обычно* не требуется, так как сборщик мусора в Go работает автоматически, но в данном случае это используется для демонстрации.  `runtime.KeepAlive(two)` гарантирует, что переменная `two` (результат `keepFirstTwoElementsOnly()`) не будет собрана сборщиком мусора до этого момента.  Это важно, потому что иначе оптимизатор мог бы решить, что `two` больше не используется, и освободить память *до* вызова `printAlloc()`, что исказило бы результаты.  Затем вызывается `printAlloc()` в последний раз, чтобы показать, сколько памяти осталось выделено после сборки мусора.

## Объяснение результатов

Если запустить этот код, то вывод будет примерно следующим (цифры могут немного отличаться):

```
8 KB
1000008 KB
1000008 KB
```

1.  **Начальное выделение:** Небольшое начальное значение (около 8 КБ) отражает память, используемую самой программой и срезом `foos` (но *не* памятью, выделенной для срезов байт внутри `Foo`).
2.  **После цикла:** Значительное увеличение (примерно до 1000 МБ) отражает выделение 1000 срезов байтов по 1 МБ каждый.
3.  **После `runtime.GC()` и утечки:**  Значение *не* уменьшается, потому что срез `two` все еще удерживает ссылку на весь исходный массив, предотвращая сборку мусора.

Если использовать одно из исправленных решений в `keepFirstTwoElementsOnly()`, вывод после `runtime.GC()` будет значительно меньше (близко к 2 МБ), показывая, что память была корректно освобождена.

## Улучшения и альтернативы

1. **Профилирование:** Для более детального анализа использования памяти в реальных приложениях следует использовать инструменты профилирования, такие как `pprof` (встроенный в Go). `pprof` позволяет визуализировать распределение памяти, находить места утечек и анализировать производительность.

Пример использования pprof:

```go
package main

import (
	"fmt"
	"os"
	"runtime"
	"runtime/pprof"
)

// ... (остальной код)

func main() {
    f, err := os.Create("mem.prof")
    if err != nil {
        fmt.Println(err)
		return
    }
    defer f.Close()

	foos := make([]Foo, 1_000)
    // ... (остальной код)

	runtime.GC()
	if err := pprof.WriteHeapProfile(f); err != nil {
		fmt.Println(err)
	}
}
```
Затем можно проанализировать mem.prof: `go tool pprof mem.prof`

2. **Использование пулов объектов (`sync.Pool`):** Если объекты типа `Foo` создаются и уничтожаются очень часто, можно использовать `sync.Pool` для повторного использования объектов, уменьшая нагрузку на сборщик мусора и количество аллокаций.

```go
var fooPool = sync.Pool{
	New: func() interface{} {
		return &Foo{v: make([]byte, 1024*1024)}
	},
}

// ...
	for i := 0; i < len(foos); i++ {
		foo := fooPool.Get().(*Foo)
        // обнуляем ссылку, чтобы не было утечек
        foo.v = foo.v[:cap(foo.v)]
		foos[i] = *foo
		fooPool.Put(foo) // Возвращаем объект в пул
	}
```

3. **Оптимизация структур данных:** В некоторых случаях можно пересмотреть структуру данных. Например, если `Foo` используется редко, а `v` часто, то можно вынести `v` в отдельную переменную, а в `Foo` хранить указатель на нее. Это уменьшит размер объектов `Foo` и может улучшить производительность.

4. **Уменьшение размера срезов:** Если возможно, следует рассмотреть возможность уменьшения размера срезов `v`.  Выделение больших кусков памяти может быть неэффективным, особенно если они используются не полностью.

## Заключение

`runtime.MemStats` и `runtime.GC()` — полезные инструменты для понимания и оптимизации использования памяти в Go-приложениях.  Предоставленный код демонстрирует, как можно использовать эти инструменты для выявления утечек памяти, связанных с особенностями работы срезов в Go.  Однако для более сложного анализа и профилирования рекомендуется использовать специализированные инструменты, такие как `pprof`. Важно помнить о разнице между срезами и массивами, а также о том, как срезы могут удерживать ссылки на базовые массивы, предотвращая сборку мусора. Использование пулов объектов (`sync.Pool`) и оптимизация структур данных также могут помочь в улучшении производительности и уменьшении потребления памяти.

```old
с помощью `runtime.Memstats` мы можем записывать статистику распределителя памяти, например количество байтов, выделенных в куче:

\`\`\`go
func printAlloc() {
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	fmt.Printf("%d KB\n", m.Alloc/1024)
}
\`\`\`

функция полезна для изучения поведения `runtime.GC()`

\`\`\`go
package main

import (
	"fmt"
	"runtime"
)

type Foo struct {
	v []byte
}

func main() {
	foos := make([]Foo, 1_000)
	printAlloc()
	for i := 0; i < len(foos); i++ {
		foos[i] = Foo{
			v: make([]byte, 1024*1024),
		}
	}
	printAlloc()
	two := keepFirstTwoElementsOnly(foos)
	runtime.GC()           // Вызывается GC, чтобы принудительно вызвать очистку кучи printAlloc()
	runtime.KeepAlive(two) // Сохраняется ссылка на переменную two
	printAlloc()
}

func keepFirstTwoElementsOnly(foos []Foo) []Foo {
  // утечка
  return foos[:2]
  // решение с расходом mem
	// res := make([]Foo, 2)
	// copy(res, foos)
	// return res
  // решение с расходом cpu
	// for i := 2; i < len(foos); i++ {
	// 	foos[i].v = nil
	// }
	// return foos[:2]
}
\`\`\`

```