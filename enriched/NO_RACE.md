#datarace #go #concurrency #race_detector #programming #golang #example #infinite_loop #scheduler #goroutine

# Пример гонки данных в Go, которую `-race` может не обнаружить

```table-of-contents
```

## Введение

Рассмотрим пример кода на Go, демонстрирующий ситуацию, когда флаг `-race` может не обнаружить состояние гонки данных, несмотря на его наличие. Этот пример подчеркивает важность понимания тонкостей работы планировщика Go и механизма обнаружения гонок.

## Код примера

```go
package main

func main() {
	i := 0
	for {
		go func() {
			i++
		}()
		go func() {
			i++
		}()
		println(i)
	}
}
```

## Анализ кода

1.  **Инициализация переменной:**
    Объявляется и инициализируется целочисленная переменная `i` значением 0. Эта переменная будет использоваться в нескольких горутинах, что и создаст условия для гонки данных.

2.  **Бесконечный цикл:**
    `for {}` создает бесконечный цикл. Внутри этого цикла постоянно запускаются новые горутины и происходит вывод значения переменной `i`.

3.  **Запуск горутин:**
    Внутри цикла запускаются две анонимные горутины. Обе горутины инкрементируют переменную `i` (`i++`).  Поскольку `i` является общей переменной, доступ к которой не синхронизирован, возникает состояние гонки данных.

4.  **Вывод значения:**
    `println(i)` выводит текущее значение переменной `i`. Этот вывод также происходит в контексте основной горутины и конкурирует с другими горутинами за доступ к `i`.

## Почему `-race` может не обнаружить гонку

Ключевым моментом здесь является наличие бесконечного цикла `for {}`.  Детектор гонок (`-race`) работает, вставляя в код специальные инструкции, которые отслеживают доступ к памяти.  Однако, если планировщик Go не переключает контекст между горутинами достаточно часто, детектор гонок может не зафиксировать одновременный доступ к переменной `i`.

В данном случае, из-за высокой частоты создания новых горутин и интенсивной работы внутри цикла, планировщик может давать преимущество основной горутине или вновь создаваемым горутинам, не давая достаточного времени на выполнение другим горутинам, уже находящимся в очереди. Это приводит к тому, что одновременный доступ к переменной i, который фактически происходит, может не быть "пойман" детектором, так как переключения контекста происходят не в те моменты, когда происходит одновременный доступ.

Если убрать бесконечный цикл `for {}`, то есть дать программе завершиться, планировщик Go с большей вероятностью переключит контекст между горутинами, и детектор гонок сможет обнаружить одновременный доступ к `i`.

## Альтернативные решения и объяснение

1.  **Удаление `for {}`:** Если убрать бесконечный цикл, программа выполнится несколько раз (в зависимости от планировщика), создаст несколько горутин, и, скорее всего, `-race` обнаружит гонку данных.  Это произойдет потому, что у планировщика будет больше возможностей для переключения контекста между горутинами до завершения программы.

2.  **Добавление `time.Sleep`:** Добавление небольшой паузы `time.Sleep` внутрь цикла может помочь детектору гонок обнаружить проблему.  Эта пауза даст планировщику возможность переключать контекст между горутинами более предсказуемо.

    ```go
    package main

    import "time"

    func main() {
    	i := 0
    	for {
    		go func() {
    			i++
    		}()
    		go func() {
    			i++
    		}()
    		println(i)
    		time.Sleep(time.Microsecond) // Добавляем паузу
    	}
    }
    ```

3.  **Использование примитивов синхронизации:**  Наиболее правильным решением является использование примитивов синхронизации, таких как мьютексы (`sync.Mutex`) или атомарные операции (`sync/atomic`).  Это гарантирует, что доступ к переменной `i` будет синхронизирован, и гонки данных не возникнет.

    ```go
    package main

    import (
    	"sync"
    )

    func main() {
    	var i int32
        var mu sync.Mutex
    	for {
    		go func() {
                mu.Lock()
    			i++
                mu.Unlock()
    		}()
    		go func() {
                mu.Lock()
    			i++
                mu.Unlock()
    		}()
    		println(i)

    	}
    }

    ```
    В данном примере используется мьютекс.

    ```go
        package main

        import (
            "sync/atomic"
        )

        func main() {
            var i int32 = 0

            for {
                go func() {
                    atomic.AddInt32(&i, 1)
                }()
                go func() {
                    atomic.AddInt32(&i, 1)
                }()
                println(atomic.LoadInt32(&i))
            }
        }
    ```
В этом же примере используется атомарная операция.

## Вывод
Приведенный пример демонстрирует, что детектор гонок `-race` не является панацеей. Он может не обнаружить гонки данных в определенных сценариях, особенно связанных с интенсивной работой планировщика и непредсказуемым переключением контекста. Для надежного предотвращения гонок данных необходимо использовать примитивы синхронизации, такие как мьютексы или атомарные операции. [[Мьютекс]] [[Атомарные операции]]

```old
пример, когда -race не обнаруживает гонку данных (если убрать for {}, то обнаруживает)

\`\`\`go
package main

func main() {
	i := 0
	for {
		go func() {
			i++
		}()
		go func() {
			i++
		}()
		println(i)
	}
}
\`\`\`

```