#golang #go #defer #receiver #pointer #struct #method #execution #scope #evaluation

# Отложенный вызов метода и изменение структуры

```table-of-contents
```

## Разбор кода и объяснение поведения

Представленный код демонстрирует тонкости работы с `defer` в Go, особенно в сочетании с методами структур и изменением значений полей структуры после планирования отложенного вызова.

**Ключевые компоненты:**

1.  **Структура `Struct`:**

    ```go
    type Struct struct {
    	id string
    }
    ```

    Определяет структуру с одним строковым полем `id`.
2.  **Метод `print()`:**

    ```go
    func (s Struct) print() {
    	fmt.Println(s.id) // foo
    }
    ```

    Это метод, связанный со структурой `Struct`.  Важно отметить, что получатель `s` является *значением*, а не указателем на структуру. Это означает, что метод работает с *копией* структуры, существовавшей на момент вызова метода.
3.  **Функция `main()`:**

    ```go
    func main() {
    	s := Struct{id: "foo"}
    	defer s.print() // s вычисляется немедленно
    	s.id = "bar"    // обновление s.id (невидимое)
    }
    ```

    -   Создается экземпляр структуры `Struct` с `id`, равным "foo".
    -   `defer s.print()`:  Это ключевой момент.  Оператор `defer` откладывает выполнение вызова `s.print()` до момента завершения функции `main()`.  Важно, что аргументы функции, передаваемые в `defer`, вычисляются *немедленно*. В данном случае `s` (копия структуры) вычисляется в момент вызова `defer`. То есть, копия структуры с `id = "foo"` "запоминается" для последующего вызова.
    -   `s.id = "bar"`:  Значение поля `id` *оригинальной* структуры `s` изменяется на "bar".  Однако это изменение *не влияет* на копию структуры, которая была "захвачена" оператором `defer`.

**Пошаговое выполнение:**

1.  Создание `s`:  `s` инициализируется как `Struct{id: "foo"}`.
2.  `defer s.print()`:  Вызов `s.print()` откладывается.  При этом *копия* `s` (со значением `id`, равным "foo") передается в качестве аргумента в отложенный вызов.
3.  `s.id = "bar"`:  Поле `id` *оригинальной* структуры `s` изменяется на "bar".
4.  Завершение `main()`:  Выполняется отложенный вызов `s.print()`.  Поскольку `print()` работает с *копией* структуры, которая была захвачена на шаге 2, выводится "foo".

## Изменение получателя на указатель

Если изменить получатель метода `print()` на указатель, поведение изменится:

```go
package main

import "fmt"

func main() {
	s := Struct{id: "foo"}
	defer s.print() // s вычисляется немедленно, но s - это ссылка
	s.id = "bar"    // обновление s.id (видимое)
}

type Struct struct {
	id string
}

func (s *Struct) print() {
	fmt.Println(s.id) // bar
}
```

**Изменения и их влияние:**

-   `func (s *Struct) print()`:  Получатель теперь `*Struct`, то есть указатель на структуру.  Это означает, что метод работает непосредственно с *оригинальной* структурой, а не с её копией.
-   `defer s.print()`: Аргументом в `defer` всё ещё является `s` (теперь указатель) и он вычисляется немедленно, но это указатель на оригинальную структуру.
-   `s.id = "bar"`:  Изменение поля `id` оригинальной структуры `s` теперь *влияет* на то, что будет выведено отложенным вызовом `print()`, т.к. метод по указателю работает с оригиналом, который был изменён.
-   При завершении `main()` и выполнении отложенного вызова `s.print()`, будет выведено "bar", поскольку метод обращается к полю `id` *оригинальной* структуры, которое было изменено.

**Пошаговое выполнение (с указателем):**

1.  Создание `s`: `s` инициализируется как `Struct{id: "foo"}`.
2.  `defer s.print()`: Вызов `s.print()` откладывается. Поскольку `s` теперь указатель, то в defer передаётся указатель на *оригинальную* структуру.
3.  `s.id = "bar"`: Поле `id` *оригинальной* структуры `s` изменяется на "bar".
4.  Завершение `main()`: Выполняется отложенный вызов `s.print()`. Метод `print()` обращается к оригинальной структуре по указателю, и видит изменённое значение `id`, поэтому выводится "bar".

## Подробное объяснение `defer`

Оператор `defer` в Go используется для откладывания выполнения функции или метода до тех пор, пока окружающая функция не завершится. Это может произойти либо из-за обычного возврата, либо из-за паники.

**Ключевые особенности `defer`:**

1.  **Отложенное выполнение:**  Функция, вызов которой отложен с помощью `defer`, не выполняется немедленно.  Вместо этого, её выполнение откладывается до момента *непосредственно перед* завершением окружающей функции.
2.  **Вычисление аргументов:** Аргументы функции, передаваемые в `defer`, вычисляются *в момент вызова* `defer`, а не в момент фактического выполнения отложенной функции.  Это критически важно для понимания поведения кода в примере.
3.  **Порядок выполнения (LIFO):** Если в функции есть несколько операторов `defer`, отложенные вызовы выполняются в порядке "последний вошел, первый вышел" (LIFO - Last In, First Out). То есть, последний отложенный вызов будет выполнен первым, а первый отложенный – последним.
4.  **Использование для очистки ресурсов:** `defer` часто используется для гарантированного освобождения ресурсов (закрытие файлов, сетевых соединений, разблокировка мьютексов), независимо от того, как завершилась функция (успешно или с ошибкой).
5. **Область видимости и замыкания:** Отложенные функции имеют доступ к переменным окружающей функции, даже после её завершения, благодаря механизму замыканий [[closures]]. Однако важно помнить о вычислении аргументов в момент вызова `defer`.

**Пример с LIFO:**

```go
package main

import "fmt"

func main() {
	defer fmt.Println("1")
	defer fmt.Println("2")
	defer fmt.Println("3")
	fmt.Println("main function")
}

```

**Вывод:**

```
main function
3
2
1
```

Сначала выводится сообщение из `main`, а затем отложенные вызовы в обратном порядке.

## Заключение

Разница в поведении кода при использовании получателя-значения и получателя-указателя в сочетании с `defer` обусловлена тем, что при использовании получателя-значения метод работает с *копией* структуры, захваченной в момент вызова `defer`, а при использовании получателя-указателя – с *оригинальной* структурой.  Понимание этого различия, а также особенностей работы `defer` (в частности, момента вычисления аргументов), является ключом к написанию корректного и предсказуемого кода на Go.

```old
Если изменить получателя на указатель, то напечатает "bar" (иначе "foo")

\`\`\`go
package main

import "fmt"

func main() {
	s := Struct{id: "foo"}
	defer s.print() // s вычисляется немедленно
	s.id = "bar"    // обновление s.id (невидимое)
}

type Struct struct {
	id string
}

func (s Struct) print() {
	fmt.Println(s.id) // foo
}
\`\`\`

```