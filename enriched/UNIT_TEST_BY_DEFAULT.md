#unitTesting #testing #softwareDevelopment #mocking #dependencies #go #programming #development #tests #unit

# Unit-тесты: Изоляция зависимостей и мокирование

```table-of-contents
```

## Введение в Unit-тестирование и мокирование

Разработка программного обеспечения неизбежно связана с необходимостью тестирования кода. Одним из наиболее распространенных и эффективных подходов является юнит-тестирование (unit testing). Юнит-тесты предназначены для проверки отдельных, изолированных компонентов (юнитов) кода, таких как функции, методы или классы. Ключевая особенность юнит-тестов – *изоляция*. Юнит должен тестироваться независимо от других частей системы, что позволяет точно определить источник ошибки в случае неудачи теста.

Для достижения изоляции часто используется техника *мокирования* (mocking). Мокирование заключается в замене реальных зависимостей юнита на их имитации – *моки* (mocks). Моки представляют собой контролируемые заглушки, которые ведут себя предсказуемым образом и позволяют имитировать различные сценарии работы зависимостей, включая ошибки и исключительные ситуации.

## Преимущества мокирования в Unit-тестах

Использование моков при написании юнит-тестов предоставляет ряд существенных преимуществ:

1.  **Изоляция**: Моки позволяют сосредоточиться исключительно на тестируемом юните, исключая влияние внешних факторов, таких как сетевые соединения, базы данных или другие сервисы. Это упрощает локализацию ошибок, поскольку неудача теста с высокой вероятностью указывает на проблему именно в тестируемом коде.

2.  **Скорость**: Юнит-тесты с моками выполняются значительно быстрее, чем тесты, взаимодействующие с реальными зависимостями. Это особенно важно при большом количестве тестов, поскольку позволяет сократить время выполнения всего набора тестов и ускорить процесс разработки.

3.  **Предсказуемость**: Моки обеспечивают предсказуемое поведение зависимостей, что позволяет создавать тесты, которые проверяют различные сценарии, включая крайние случаи и ошибки. Это повышает надежность и качество тестирования.

4.  **Простота настройки**: Современные инструменты для мокирования позволяют легко создавать и настраивать моки, что упрощает процесс написания тестов.

5.  **Тестирование недоступных зависимостей**: Моки позволяют тестировать код, который взаимодействует с еще не разработанными или недоступными зависимостями. Это особенно полезно при параллельной разработке разных компонентов системы.

## Пример использования моков в Go

Рассмотрим пример использования моков в Go с помощью библиотеки `testify/mock`. Предположим, у нас есть функция `GetUser`, которая получает данные пользователя из базы данных:

```go
package user

import (
	"database/sql"
	"fmt"
)

// User represents a user.
type User struct {
	ID   int
	Name string
}

// UserRepository provides access to user data.
type UserRepository interface {
	GetByID(id int) (*User, error)
}

// UserService provides user-related functionality.
type UserService struct {
	repo UserRepository
}

// NewUserService creates a new UserService.
func NewUserService(repo UserRepository) *UserService {
	return &UserService{repo: repo}
}

// GetUser retrieves a user by ID.
func (s *UserService) GetUser(id int) (*User, error) {
	return s.repo.GetByID(id)
}
```

В этом примере `UserService` зависит от интерфейса `UserRepository`. Для тестирования функции `GetUser` мы можем создать мок-реализацию `UserRepository`:

```go
package user

import (
	"testing"

	"github.com/stretchr/testify/mock"
)

// MockUserRepository is a mock implementation of UserRepository.
type MockUserRepository struct {
	mock.Mock
}

// GetByID mocks the GetByID method.
func (m *MockUserRepository) GetByID(id int) (*User, error) {
	args := m.Called(id)
	return args.Get(0).(*User), args.Error(1)
}
```

Теперь мы можем написать юнит-тест для функции `GetUser`:

```go
package user

import (
	"errors"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestUserService_GetUser(t *testing.T) {
	// Создаем мок UserRepository.
	mockRepo := new(MockUserRepository)

	// Настраиваем ожидаемое поведение мока.
	// В первом случае мок возвращает пользователя.
	mockRepo.On("GetByID", 1).Return(&User{ID: 1, Name: "Test User"}, nil)
	// Во втором случае мок возвращает ошибку.
    mockRepo.On("GetByID", 2).Return((*User)(nil), errors.New("user not found"))

	// Создаем UserService с мок-репозиторием.
	userService := NewUserService(mockRepo)

	// Тестируем первый случай (успешное получение пользователя).
	user, err := userService.GetUser(1)
	assert.NoError(t, err)
	assert.Equal(t, &User{ID: 1, Name: "Test User"}, user)

    // Тестируем второй случай (ошибка получения пользователя).
    user2, err2 := userService.GetUser(2)
    assert.Error(t, err2)
    assert.Nil(t, user2)
    assert.Equal(t, "user not found", err2.Error())

	// Убеждаемся, что мок был вызван с ожидаемыми аргументами.
	mockRepo.AssertExpectations(t)
}
```
В этом тесте мы:

1.  Создаем экземпляр `MockUserRepository`.
2.  Используем метод `On` для настройки ожидаемого поведения мока:
    *   Когда вызывается метод `GetByID` с аргументом 1, мок должен вернуть пользователя с ID 1 и именем "Test User" без ошибки.
    *   Когда вызывается метод `GetByID` с аргументом 2, мок должен вернуть `nil` (в качестве пользователя) и ошибку "user not found".
3.  Создаем `UserService`, передавая ему мок-репозиторий.
4.  Вызываем функцию `GetUser` с разными аргументами и проверяем результаты с помощью утверждений (assertions) из пакета `testify/assert`.
    *   `assert.NoError(t, err)` проверяет, что ошибка `err` равна `nil`.
    *   `assert.Equal(t, expected, actual)` проверяет что фактическое значение `actual` равно ожидаемому `expected`.
    *   `assert.Error(t, err)` проверяет, что ошибка `err` не равна `nil`.
    *   `assert.Nil(t, user)` проверяет, что пользователь `user` равен `nil`.
5.  Вызываем `mockRepo.AssertExpectations(t)` , чтобы убедиться, что все ожидаемые вызовы мока действительно произошли.

## Альтернативные подходы к тестированию зависимостей

Хотя мокирование является распространенным и эффективным подходом, существуют и другие методы тестирования зависимостей:

1.  **Использование реальных зависимостей**: В некоторых случаях можно использовать реальные зависимости, например, тестовую базу данных или in-memory хранилище. Этот подход может быть полезен для интеграционного тестирования, но он менее подходит для юнит-тестов из-за сложности настройки и медленной скорости выполнения.

2.  **Заглушки (Stubs)**: Заглушки, как и моки, являются имитациями зависимостей, но, как правило, имеют более простую реализацию и не поддерживают проверку вызовов. Они могут быть полезны в простых случаях, когда не требуется сложная логика мокирования.

3.  **Фейки (Fakes)**: Фейки представляют собой более сложные имитации зависимостей, которые могут иметь упрощенную, но работающую реализацию. Например, фейковая база данных может хранить данные в памяти вместо реальной базы данных. Фейки могут быть полезны, когда требуется более сложное поведение, чем могут предоставить заглушки, но мокирование слишком сложно.

4.  **Шпионы (Spies)**: Шпионы позволяют отслеживать вызовы реальных зависимостей, записывая информацию о вызовах, аргументах и возвращаемых значениях. Они могут быть полезны для проверки взаимодействия между компонентами, но не подходят для изоляции юнитов.

Выбор конкретного подхода зависит от контекста и целей тестирования. Для юнит-тестов, как правило, предпочтительнее использовать моки из-за их преимуществ в изоляции, скорости и предсказуемости.

## Заключение

Мокирование является мощным инструментом для написания эффективных и надежных юнит-тестов. Оно позволяет изолировать тестируемый код от внешних зависимостей, обеспечивая скорость, предсказуемость и простоту настройки тестов. В Go существует множество библиотек для мокирования, таких как `testify/mock`, `gomock` и другие, которые упрощают создание и использование моков. Правильное использование моков позволяет значительно повысить качество и надежность разрабатываемого программного обеспечения.  [[Юнит-тестирование]] [[Мокирование]] [[Go]] [[Testify]] [[Gomock]]

```old
По дефолту мы пишем unit-тесты, где замоканы все внешние зависимости, потому что такие тесты писать легко, дёшево и удобно (т.е. не нужно поднимать один сервис в докере, чтобы протестировать потребителя этого сервиса).
```