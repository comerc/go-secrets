#generateParenthesis #go #recursion #backtracking #parentheses #combinations #string #leetcode #algorithm #dynamic_programming

# Генерация правильных скобочных последовательностей

```table-of-contents
```

Задача состоит в том, чтобы сгенерировать все возможные комбинации *правильно* сформированных скобок для заданного числа `n`, представляющего количество пар скобок. Правильно сформированные скобки означают, что каждая открывающая скобка `(` имеет соответствующую закрывающую скобку `)`, и скобки вложены корректно.

## Решение с использованием рекурсии и backtracking

Предоставленный Go код реализует решение с использованием рекурсии и техники, называемой [[backtracking]].

### Подробное описание алгоритма

1.  **Инициализация:**
    *   Создается пустой строковый слайс `result` для хранения результирующих скобочных последовательностей.
    *   Определяется внутренняя рекурсивная функция `backtrack`.

2.  **Рекурсивная функция `backtrack`:**
    *   Принимает три параметра:
        *   `s`: Текущая строящаяся скобочная последовательность (string).
        *   `left`: Количество уже использованных открывающих скобок.
        *   `right`: Количество уже использованных закрывающих скобок.
    *   **Базовый случай (условие остановки рекурсии):** Если длина строки `s` достигла `2*n` (т.е., использованы все скобки), текущая последовательность `s` добавляется в `result`, и функция завершает работу.
    *   **Рекурсивные шаги:**
        *   **Добавление открывающей скобки:** Если количество открывающих скобок `left` меньше `n` (т.е., еще можно добавить открывающую скобку), функция вызывает сама себя, добавляя к строке `s` открывающую скобку "(", увеличивая `left` на 1, и оставляя `right` без изменений.
        *   **Добавление закрывающей скобки:** Если количество закрывающих скобок `right` меньше количества открывающих скобок `left` (т.е., есть "неспаренная" открывающая скобка, которую можно закрыть), функция вызывает сама себя, добавляя к строке `s` закрывающую скобку ")", оставляя `left` без изменений и увеличивая `right` на 1.

3.  **Начальный вызов:** Функция `backtrack` вызывается изначально с пустой строкой `""`, `left = 0` и `right = 0`.

4.  **Возврат результата:** После завершения всех рекурсивных вызовов функция `GenerateParenthesis` возвращает слайс `result`, содержащий все сгенерированные правильные скобочные последовательности.

### Пошаговый пример для n = 2

1.  `backtrack("", 0, 0)`
2.  `left < 2` -> `backtrack("(", 1, 0)`
3.  `left < 2` -> `backtrack("((", 2, 0)`
4.  `len(s) == 4` -> `result = ["(("]`
5.  `right < left` -> `backtrack("(()", 2, 1)`
6.  `len(s) == 4` -> `result = ["((", "(()"]`
7.  `right < left` -> `backtrack("(())", 2, 2)`
8.  `len(s) == 4` -> `result = ["((", "(()", "(())"]`
9.  `right < left` -> `backtrack("()", 1, 1)`
10. `left < 2` -> `backtrack("()(", 2, 1)`
11. `len(s) == 4` -> `result = ["((", "(()", "(())", "()("]`
12. `right < left` -> `backtrack("()()", 2, 2)`
13. `len(s) == 4` -> `result = ["((", "(()", "(())", "()(", "()()"]`

Итоговый `result`: `["(())", "()()"]`.

### Обоснование лексикографического порядка

Лексикографический порядок (порядок, как в словаре) обеспечивается порядком рекурсивных вызовов. Сначала всегда исследуется возможность добавления открывающей скобки, и только потом – закрывающей. Это гарантирует, что последовательности, начинающиеся с большего количества открывающих скобок, будут сгенерированы раньше.

### Сложность

*   **Временная сложность:**  Число правильных скобочных последовательностей растет экспоненциально как числа Каталана: $C_n = \frac{(2n)!}{(n+1)!n!}$. Временная сложность алгоритма пропорциональна этому числу, т.е. O($C_n$). Более грубая оценка, которую проще понять, O($4^n / n^{3/2}$).
*   **Пространственная сложность:**  O($4^n / n^{3/2}$) для хранения результата + O($n$) для стека рекурсии (максимальная глубина рекурсии равна $2n$).

### Альтернативные решения

1.  **Динамическое программирование:** Можно решить задачу с помощью динамического программирования. Создается таблица `dp`, где `dp[i]` хранит список всех правильных скобочных последовательностей длины `2*i`.  `dp[i]` можно построить, комбинируя элементы из `dp[j]` и `dp[i-1-j]` для всех `j` от 0 до `i-1`.

    ```go
    func GenerateParenthesisDP(n int) []string {
        dp := make([][]string, n+1)
        dp[0] = []string{""}

        for i := 1; i <= n; i++ {
            for j := 0; j < i; j++ {
                for _, left := range dp[j] {
                    for _, right := range dp[i-1-j] {
                        dp[i] = append(dp[i], "("+left+")"+right)
                    }
                }
            }
        }
        return dp[n]
    }

    ```

    *   **Временная сложность:** O($n * C_n$).
    *   **Пространственная сложность:** O($n * C_n$).
  Преимущество данного подхода в том, что он избегает повторных вычислений, характерных для рекурсивного подхода, за счет использования таблицы для хранения промежуточных результатов.

2.  **Итеративный подход с использованием BFS (поиск в ширину):** Можно использовать очередь для хранения промежуточных состояний (строка, количество открытых, количество закрытых скобок) и итеративно строить все возможные последовательности.
    ```go
    func GenerateParenthesisBFS(n int) []string {
    	type state struct {
    		s     string
    		left  int
    		right int
    	}
    	result := []string{}
    	queue := []state{{s: "", left: 0, right: 0}}

    	for len(queue) > 0 {
    		curr := queue[0]
    		queue = queue[1:]

    		if len(curr.s) == 2*n {
    			result = append(result, curr.s)
    			continue
    		}

    		if curr.left < n {
    			queue = append(queue, state{s: curr.s + "(", left: curr.left + 1, right: curr.right})
    		}
    		if curr.right < curr.left {
    			queue = append(queue, state{s: curr.s + ")", left: curr.left, right: curr.right + 1})
    		}
    	}
    	return result
    }

    ```

    *   **Временная сложность:**  O($C_n$).
    *   **Пространственная сложность:** O($C_n$).

### Сравнение решений
| Решение                       | Временная сложность | Пространственная сложность | Преимущества                                         | Недостатки                                                                                               |
| :------------------------------ | :----------------- | :----------------------- | :--------------------------------------------------- | :------------------------------------------------------------------------------------------------------- |
| Рекурсия + Backtracking        | O($C_n$)            | O($C_n$)                 | Простота реализации, естественный порядок генерации. | Может быть менее эффективным из-за повторных вычислений.                                             |
| Динамическое программирование | O($n*C_n$)          | O($n*C_n$)               | Избегает повторных вычислений.                      | Более сложная реализация, требует дополнительной памяти для таблицы.                                     |
| BFS                            | O($C_n$)           | O($C_n$)               | Итеративный подход.                                   | Может быть менее интуитивно понятным, чем рекурсивный подход, требует использование структуры данных (очереди). |

В данном случае, для практического применения при небольших значениях `n`, рекурсивный подход с backtracking является достаточно эффективным и простым в реализации. При больших `n` можно рассмотреть использование динамического программирования, но для данной задачи разница не будет слишком значительной, т.к. количество комбинаций растёт очень быстро.

```old
\`\`\`go
package article

// Функция generateParenthesis использует рекурсивный алгоритм с возвратом (backtracking),
// который генерирует все возможные правильные скобочные последовательности длины 2*n.
// При этом алгоритм автоматически гарантирует лексикографический порядок в ответе.

// В функции generateParenthesis определена внутренняя функция backtrack,
// которая принимает три аргумента: текущую скобочную последовательность s,
// количество открывающих скобок left и количество закрывающих скобок right.
// Если длина текущей последовательности равна 2*n, то она добавляется в результат.
// В противном случае, если количество открывающих скобок меньше n,
// то мы можем добавить открывающую скобку.
// Если количество закрывающих скобок меньше количества открывающих скобок,
// то мы можем добавить закрывающую скобку.

// выводит все правильные скобочные последовательности длины 2*n, упорядоченные лексикографически
func GenerateParenthesis(n int) []string {
	var result []string
	var backtrack func(s string, left, right int)
	backtrack = func(s string, left, right int) {
		if len(s) == 2*n {
			result = append(result, s)
			return
		}
		if left < n {
			backtrack(s+"(", left+1, right)
		}
		if right < left {
			backtrack(s+")", left, right+1)
		}
	}
	backtrack("", 0, 0)
	return result
}
\`\`\`
```