#golang #string #comparison #algorithm #sorting #hashmap #tradeoff #space_complexity #time_complexity #mutability

# Сравнение строк в Golang: Алгоритмический подход

```table-of-contents
```

Задача состоит в том, чтобы определить, состоят ли две строки из одинаковых символов, независимо от их порядка.  Представлены два подхода к решению этой задачи на языке Golang: с использованием хэш-таблиц (map) и с использованием сортировки. Рассмотрим подробно каждый из них, а так же приведем пример с пузырьковой сортировкой.

## Подход 1: Использование хэш-таблиц (map)

Этот подход основан на подсчете количества вхождений каждого символа в обеих строках. Для этого используются две хэш-таблицы (словари в терминах Go).

**Шаг 1: Инициализация словарей.**

Создаются два словаря `dict1` и `dict2` типа `map[rune]int`.  Ключом в словаре является символ (rune), а значением - количество его вхождений в строке.  Использование `rune` важно для корректной обработки Unicode символов, которые могут быть представлены несколькими байтами.

```go
dict1 := make(map[rune]int)
dict2 := make(map[rune]int)
```

**Шаг 2: Подсчет символов в первой строке.**

Итерируемся по первой строке `s1` и для каждого символа увеличиваем счетчик в `dict1`.

```go
for _, char := range s1 {
    dict1[char]++
}
```
Оператор `++` увеличивает значение по ключу `char` на единицу. Если ключа еще нет в словаре, он создается со значением 1.

**Шаг 3: Подсчет символов во второй строке.**

Аналогично шагу 2, итерируемся по второй строке `s2` и подсчитываем символы в `dict2`.

```go
for _, char := range s2 {
    dict2[char]++
}
```

**Шаг 4: Сравнение словарей.**

Функция `compareMaps` сравнивает два словаря.

```go
func compareMaps(map1, map2 map[rune]int) bool {
	if len(map1) != len(map2) {
		return false
	}

	for key, val1 := range map1 {
		val2, ok := map2[key]
		if !ok || val1 != val2 {
			return false
		}
	}

	return true
}
```

Сначала проверяется равенство длин словарей. Если длины не равны, словари заведомо не идентичны. Затем происходит итерация по первому словарю.  Для каждого ключа `key` и значения `val1` из `map1` проверяется наличие такого же ключа в `map2` с помощью выражения `val2, ok := map2[key]`. Если ключ отсутствует (`ok == false`) или значения по ключу отличаются (`val1 != val2`), словари считаются разными.

**Шаг 5: Возврат результата.**

Функция `CompareStrings1` возвращает 1, если словари идентичны, и 0 в противном случае.

```go
func CompareStrings1(s1, s2 string) int {
	// ... (шаги 1-4) ...

	if compareMaps(dict1, dict2) {
		return 1
	} else {
		return 0
	}
}
```

**Преимущества:**

*   **Скорость:**  Операции с хэш-таблицами (вставка, поиск) в среднем выполняются за время O(1).  Общая сложность алгоритма близка к O(n), где n - длина большей из строк.
*   **Неизменяемость входных данных:** Исходные строки `s1` и `s2` не модифицируются.

**Недостатки:**

*   **Дополнительная память:** Требуется память для хранения двух словарей.  В худшем случае, когда все символы в строках уникальны, расход памяти будет пропорционален длине строк.

## Подход 2: Использование сортировки

Этот подход основан на сортировке символов в обеих строках и последующем их сравнении.

**Шаг 1: Сортировка первой строки.**

Функция `sortString1` сортирует символы в строке. Сначала строка преобразуется в срез рун `[]rune(s)`.  Затем используется функция `sort.Slice` из стандартной библиотеки `sort`.  Эта функция принимает срез и функцию-компаратор, которая определяет порядок сортировки.  В данном случае используется анонимная функция, которая сравнивает два символа `chars[i]` и `chars[j]`.

```go
func sortString1(s string) string {
	chars := []rune(s)
	sort.Slice(chars, func(i, j int) bool {
		return chars[i] < chars[j]
	})
	return string(chars)
}
```

**Шаг 2: Сортировка второй строки.**

Для примера, добавим еще один способ сортировки - Пузырьковая сортировка, реализация в `sortString2`.

```go
func sortString2(s string) string {
	chars := []rune(s)
	n := len(chars)
	for i := 0; i < n-1; i++ {
		for j := 0; j < n-i-1; j++ {
			if chars[j] > chars[j+1] {
				chars[j], chars[j+1] = chars[j+1], chars[j]
			}
		}
	}
	return string(chars)
}
```
Внешний цикл `for i := 0; i < n-1; i++` проходит по всем элементам массива.
Внутренний цикл `for j := 0; j < n-i-1; j++` сравнивает текущий элемент `chars[j]` со следующим `chars[j+1]`.
Если текущий элемент больше следующего, они меняются местами `chars[j], chars[j+1] = chars[j+1], chars[j]`.
После каждой итерации внешнего цикла наибольший элемент "всплывает" в конец массива.

**Шаг 3: Сравнение отсортированных строк.**

После сортировки обеих строк, они сравниваются напрямую.

```go
func CompareStrings2(s1, s2 string) int {
	sorted1 := sortString1(s1) // Или sortString2(s1)
	sorted2 := sortString2(s2) // Или sortString1(s2)

	if sorted1 == sorted2 {
		return 1
	} else {
		return 0
	}
}
```

**Преимущества:**

*   **Отсутствие дополнительной памяти (кроме стека вызовов для рекурсии, если используется рекурсивная сортировка):** Сортировка `sort.Slice` выполняется "на месте", то есть модифицирует исходный срез. Пузырьковая сортировка так же выполняется на месте.

**Недостатки:**

*   **Скорость:**  Сложность алгоритма сортировки `sort.Slice` в Go - O(n log n). Пузырьковая сортировка имеет сложность O(n^2). Это медленнее, чем подход с хэш-таблицами.
*   **Изменяемость входных данных:**  Исходные строки преобразуются в срезы рун, которые затем сортируются. Хотя сами строки не меняются, создается их изменяемая копия в виде среза.

## Сравнение подходов и выбор оптимального решения

| Характеристика          | Подход с хэш-таблицами | Подход с сортировкой (sort.Slice) | Подход с сортировкой (Пузырек) |
| ----------------------- | ----------------------- | --------------------------------- | ------------------------------- |
| Временная сложность     | O(n)                    | O(n log n)                       | O(n^2)                          |
| Пространственная сложность | O(n)                    | O(1) (или O(log n) для стека)  | O(1)                             |
| Изменяемость данных     | Нет                     | Да (срез)                       | Да (срез)                          |

Выбор оптимального решения зависит от конкретных требований:

*   **Если важна скорость и допустимо использование дополнительной памяти,** то лучшим выбором будет подход с хэш-таблицами.
*   **Если важна экономия памяти и производительность не является критичным фактором,** то можно использовать сортировку.
*   **Если производительность критична, а использование дополнительной памяти крайне нежелательно**, то следует использовать `sort.Slice`, т.к. пузырьковая сортировка значительно уступает по скорости.

В большинстве случаев, подход с хэш-таблицами является предпочтительным из-за своей скорости.  Подход с сортировкой может быть оправдан только в условиях жестких ограничений по памяти. Пузырьковая сортировка приведена в качестве примера алгоритма сортировки "на месте", но в реальных задачах ее использование не рекомендуется из-за низкой эффективности.

```old
\`\`\`go
package article

import (
	"sort"
)

// Оба решения имеют свои преимущества и недостатки, как вы уже упомянули.
// Решение с использованием словарей быстрее и не меняет входные данные,
// но требует дополнительной памяти для хранения словарей.
// Решение с сортировкой работает медленнее, но не требует дополнительной памяти.
// В зависимости от конкретных требований проекта, можно выбрать наиболее подходящее решение.

func compareMaps(map1, map2 map[rune]int) bool {
	if len(map1) != len(map2) {
		return false
	}

	for key, val1 := range map1 {
		val2, ok := map2[key]
		if !ok || val1 != val2 {
			return false
		}
	}

	return true
}

func CompareStrings1(s1, s2 string) int {
	dict1 := make(map[rune]int)
	dict2 := make(map[rune]int)

	for _, char := range s1 {
		dict1[char]++
	}

	for _, char := range s2 {
		dict2[char]++
	}

	if compareMaps(dict1, dict2) {
		return 1
	} else {
		return 0
	}
}

func sortString1(s string) string {
	chars := []rune(s)
	sort.Slice(chars, func(i, j int) bool {
		return chars[i] < chars[j]
	})
	return string(chars)
}

func sortString2(s string) string {
	chars := []rune(s)
	n := len(chars)
	for i := 0; i < n-1; i++ {
		for j := 0; j < n-i-1; j++ {
			if chars[j] > chars[j+1] {
				chars[j], chars[j+1] = chars[j+1], chars[j]
			}
		}
	}
	return string(chars)
}

func CompareStrings2(s1, s2 string) int {
	sorted1 := sortString1(s1)
	sorted2 := sortString2(s2)

	if sorted1 == sorted2 {
		return 1
	} else {
		return 0
	}
}
\`\`\`
```