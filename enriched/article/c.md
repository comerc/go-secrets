#removeDuplicates #algorithms #golang #arrays #inPlace #optimization #uniqueElements #timeComplexity #spaceComplexity #programming

# Удаление дубликатов в массиве Go

```table-of-contents
```

## Задача

Дан отсортированный массив целых чисел (с типом `int32`). Необходимо удалить дубликаты в этом массиве таким образом, чтобы каждый элемент появлялся только один раз. Важно решить задачу, не используя дополнительную память (in-place, O(1) по памяти).

## Решение 1: `RemoveDuplicates1`

### Описание

Функция `RemoveDuplicates1` создает новый результирующий массив, в который последовательно добавляются уникальные элементы из исходного массива.

### Шаги

1.  **Инициализация:**
    *   Создается переменная `lastValue`, в которую записывается первый элемент исходного массива.
    *   Создается результирующий массив `result`, в который добавляется `lastValue`.

2.  **Итерация по массиву:**
    *   Цикл `for` проходит по исходному массиву, начиная со второго элемента (индекс 1).

3.  **Проверка на дубликат:**
    *   Текущий элемент `arr[i]` сравнивается с `lastValue`.
    *   Если элементы равны, текущий элемент пропускается (дубликат).

4.  **Добавление уникального элемента:**
    *   Если текущий элемент не равен `lastValue`, он добавляется в `result`.
    *   `lastValue` обновляется, ей присваивается значение текущего элемента.

5.  **Возврат результата:**
    *   Функция возвращает `result`.

### Пример

```go
package main

import (
	"fmt"
)

func RemoveDuplicates1(arr []int32) []int32 {
	lastValue := arr[0]
	result := []int32{lastValue}
	for i := 1; i < len(arr); i++ {
		if arr[i] == lastValue {
			continue
		} else {
			result = append(result, arr[i])
			lastValue = arr[i]
		}
	}
	return result
}

func main() {
	arr := []int32{1, 1, 2, 2, 2, 3, 4, 4, 5}
	uniqueArr := RemoveDuplicates1(arr)
	fmt.Println(uniqueArr) // Вывод: [1 2 3 4 5]
}

```

### Плюсы и минусы

*   **Плюсы:**
    *   Простой и понятный код.

*   **Минусы:**
    *   Использует дополнительную память для создания нового массива `result`. Не соответствует условию in-place.
    *   Операция `append` может вызывать реаллокацию памяти, что влияет на производительность при больших размерах массива.

## Решение 2: `RemoveDuplicates2`

### Описание

Функция `RemoveDuplicates2` модифицирует исходный массив, перемещая уникальные элементы в начало массива.

### Шаги

1.  **Инициализация:**
    *   `uniqueIndex` инициализируется значением 1, что указывает на индекс следующего уникального элемента.

2.  **Итерация по массиву:**
    *   Внешний цикл `for` проходит по исходному массиву, начиная со второго элемента (индекс 1).

3.  **Внутренний цикл (проверка на уникальность):**
    *   Внутренний цикл `for` проходит по элементам массива от начала до `uniqueIndex`.
    *   Если текущий элемент `arr[i]` равен какому-либо элементу в уже проверенной части массива (`arr[j]`), внутренний цикл прерывается.

4.  **Добавление уникального элемента (in-place):**
    *   Если внутренний цикл завершился без нахождения дубликата (j == uniqueIndex), это означает, что `arr[i]` - уникальный элемент.
    *  `arr[uniqueIndex]` присваивается значение `arr[i]`.
    *   `uniqueIndex` увеличивается на 1.

5.  **Возврат результата:**
    *   Функция возвращает срез исходного массива от начала до `uniqueIndex`, содержащий только уникальные элементы.

### Пример

```go
package main

import (
	"fmt"
)

func RemoveDuplicates2(arr []int32) []int32 {
	uniqueIndex := 1
	for i := 1; i < len(arr); i++ {
		j := 0
		for j < uniqueIndex {
			if arr[i] == arr[j] {
				break
			}
			j++
		}
		if j == uniqueIndex {
			arr[uniqueIndex] = arr[i]
			uniqueIndex++
		}
	}
	return arr[:uniqueIndex]
}

func main() {
	arr := []int32{1, 1, 2, 2, 2, 3, 4, 4, 5}
	uniqueArr := RemoveDuplicates2(arr)
	fmt.Println(uniqueArr) // Вывод: [1 2 3 4 5]
	fmt.Println(arr)       // Вывод: [1 2 3 4 5 4 4 5] - исходный массив изменен
}

```

### Плюсы и минусы

*   **Плюсы:**
    *   Решение In-place: не использует дополнительную память (O(1) по памяти).
    *   Относительно эффективное решение.

*   **Минусы:**
    *   Более сложный код по сравнению с `RemoveDuplicates1`.
    *   Имеет квадратичную сложность O(n^2) в худшем случае (когда все элементы уникальны).

## Сравнение решений и выбор оптимального

| Решение            | Временная сложность | Пространственная сложность | In-place |
| :----------------- | :------------------ | :------------------------ | :------- |
| `RemoveDuplicates1` | O(n)                | O(n)                      | Нет      |
| `RemoveDuplicates2` | O(n^2)              | O(1)                      | Да      |

В задаче явно указано требование к пространственной сложности O(1), то есть решение должно быть in-place. Таким образом, **`RemoveDuplicates2` является предпочтительным решением**, несмотря на то, что его временная сложность в худшем случае хуже. `RemoveDuplicates1` не удовлетворяет требованию in-place.

## Оптимизация `RemoveDuplicates2`

Учитывая, что входной массив отсортирован, можно значительно оптимизировать `RemoveDuplicates2`, избавившись от вложенного цикла. Вместо вложенного цикла, проверяющего каждый элемент на уникальность, можно просто сравнивать текущий элемент с предыдущим уникальным элементом.

```go
package main

import (
	"fmt"
)

func RemoveDuplicates2Optimized(arr []int32) []int32 {
	if len(arr) == 0 { // Добавим обработку пустого массива
		return arr
	}
    uniqueIndex := 1
    for i := 1; i < len(arr); i++ {
        if arr[i] != arr[uniqueIndex-1] {
            arr[uniqueIndex] = arr[i]
            uniqueIndex++
        }
    }
    return arr[:uniqueIndex]
}

func main() {
    arr := []int32{1, 1, 2, 2, 2, 3, 4, 4, 5}
    uniqueArr := RemoveDuplicates2Optimized(arr)
    fmt.Println(uniqueArr) // Вывод: [1 2 3 4 5]
}
```

### Оптимизированная версия: Шаги

1.  **Обработка пустого массива:** Добавлена проверка на пустой массив. Если массив пуст, сразу возвращается пустой массив.
2.  **Инициализация:** `uniqueIndex` инициализируется значением 1.
3.  **Итерация по массиву:** Цикл `for` проходит по исходному массиву, начиная со второго элемента.
4.  **Сравнение с предыдущим уникальным:** Текущий элемент `arr[i]` сравнивается с предыдущим уникальным элементом `arr[uniqueIndex-1]`.
5.  **Добавление уникального элемента:** Если текущий элемент не равен предыдущему уникальному,  он записывается на позицию `uniqueIndex`, а `uniqueIndex` увеличивается.
6.  **Возврат результата:** Возвращается срез исходного массива от начала до `uniqueIndex`.

### Преимущества оптимизированной версии

*   **Временная сложность:** O(n).  Благодаря тому, что массив отсортирован, мы можем проходить по нему за один проход, сравнивая текущий элемент только с предыдущим уникальным.
*   **Пространственная сложность:** O(1). Решение остается in-place.
*   **Простота кода:** Код стал проще и понятнее, избавившись от вложенного цикла.

Оптимизированная версия `RemoveDuplicates2Optimized` является наилучшим решением данной задачи, так как удовлетворяет требованию in-place и имеет линейную временную сложность.

```old
\`\`\`go
package article

func RemoveDuplicates1(arr []int32) []int32 {
	lastValue := arr[0]
	result := []int32{lastValue}
	for i := 1; i < len(arr); i++ {
		if arr[i] == lastValue {
			continue
		} else {
			result = append(result, arr[i])
			lastValue = arr[i]
		}
	}
	return result
}

// При решении этой задачи также не нужно использовать дополнительную память.

func RemoveDuplicates2(arr []int32) []int32 {
	uniqueIndex := 1
	for i := 1; i < len(arr); i++ {
		j := 0
		for j < uniqueIndex {
			if arr[i] == arr[j] {
				break
			}
			j++
		}
		if j == uniqueIndex {
			arr[uniqueIndex] = arr[i]
			uniqueIndex++
		}
	}
	return arr[:uniqueIndex]
}
\`\`\`
```