#runtimeGosched

#goroutine #concurrency #scheduler #runtime #parallelism #programming #go #multithreading #cooperativeMultitasking

# Использование runtime.Gosched() в Go

```table-of-contents
```

## Обзор `runtime.Gosched()`

Функция `runtime.Gosched()` в Go, находящаяся в пакете `runtime`, предоставляет механизм для явной передачи управления планировщику горутин. По сути, она сигнализирует планировщику, что текущая горутина готова приостановить свое выполнение, позволяя другим горутинам получить процессорное время. Это важно для обеспечения честного распределения ресурсов и предотвращения ситуаций, когда одна горутина монополизирует процессор, не давая выполняться другим.

## Механизм работы

Когда вызывается `runtime.Gosched()`, текущая горутина перемещается в конец очереди готовых к выполнению горутин. Планировщик Go затем выбирает следующую горутину из этой очереди и запускает ее. Важно понимать, что `runtime.Gosched()` не гарантирует немедленное переключение на другую горутину. Если других готовых к выполнению горутин нет, текущая горутина может продолжить свое выполнение.

Вызов `runtime.Gosched()` является примером *кооперативной многозадачности* [[Cooperative Multitasking]]. В отличие от *вытесняющей многозадачности* [[Preemptive Multitasking]], где операционная система сама решает, когда переключать контекст между потоками, в кооперативной многозадачности горутины сами решают, когда уступить управление.

## Примеры использования

### Простой пример

Рассмотрим базовый пример, демонстрирующий работу `runtime.Gosched()`:

```go
package main

import (
	"fmt"
	"runtime"
	"sync"
)

func main() {
	var wg sync.WaitGroup
	wg.Add(2)

	go func() {
		defer wg.Done()
		for i := 0; i < 5; i++ {
			fmt.Println("Горутина 1:", i)
			runtime.Gosched() // Уступаем управление
		}
	}()

	go func() {
		defer wg.Done()
		for i := 0; i < 5; i++ {
			fmt.Println("Горутина 2:", i)
			runtime.Gosched() // Уступаем управление
		}
	}()

	wg.Wait()
}
```

В этом примере две горутины выводят числа от 0 до 4.  `runtime.Gosched()` вызывается после каждого вывода, предоставляя возможность другой горутине выполниться.  `sync.WaitGroup` используется для ожидания завершения обеих горутин. Без `runtime.Gosched()` одна из горутин, скорее всего, выполнилась бы полностью, прежде чем управление перешло бы ко второй.

### Предотвращение "голодания" горутин

Предположим, у нас есть горутина, выполняющая длительную вычислительную задачу без вызовов блокирующих операций (например, I/O).  Без `runtime.Gosched()`, эта горутина могла бы удерживать процессор в течение длительного времени, не давая другим горутинам шанса на выполнение.

```go
package main

import (
	"fmt"
	"runtime"
	"sync"
	"time"
)

func longRunningTask() {
	for i := 0; i < 1000000000; i++ {
		// Имитация длительных вычислений
		if i%100000000 == 0 {
			runtime.Gosched() // Даем шанс другим горутинам
			fmt.Println("longRunningTask yielded")
		}
	}
}

func main() {
	var wg sync.WaitGroup
	wg.Add(2)

	go func() {
		defer wg.Done()
		longRunningTask()
	}()

	go func() {
		defer wg.Done()
		for i := 0; i < 5; i++ {
			fmt.Println("Горутина 2:", i)
			time.Sleep(100 * time.Millisecond) // Добавляем небольшую задержку
		}
	}()
	wg.Wait()
}
```

В этом примере `longRunningTask()` имитирует длительные вычисления.  Вызов `runtime.Gosched()` внутри цикла позволяет другим горутинам (в данном случае, второй горутине) получать процессорное время и выполняться. Без этого вызова вторая горутина могла бы ждать очень долго.

## Альтернативы и сравнение

### `time.Sleep()`

`time.Sleep()` приостанавливает выполнение горутины на указанный промежуток времени.  Это тоже способ дать другим горутинам шанс выполниться, но он имеет существенные отличия от `runtime.Gosched()`:

*   **`time.Sleep()` блокирует горутину:** Горутина не может быть выбрана планировщиком для выполнения, пока не истечет время сна.
*   **`runtime.Gosched()` не блокирует горутину:** Горутина остается в очереди готовых к выполнению и может быть выбрана планировщиком снова, если нет других горутин, ожидающих выполнения.

`time.Sleep()` следует использовать, когда необходимо *гарантированно* приостановить выполнение на определенное время. `runtime.Gosched()` лучше подходит, когда нужно просто уступить управление, не блокируя горутину.

### Каналы (Channels)

Каналы [[Channels]] в Go предоставляют мощный механизм для синхронизации и обмена данными между горутинами. Операции отправки и получения на каналах являются блокирующими, если канал не буферизован или буфер полон/пуст. Это естественным образом приводит к переключению контекста между горутинами, если одна горутина ожидает данных от другой.

Каналы являются предпочтительным способом взаимодействия между горутинами в Go и часто позволяют избежать необходимости явного использования `runtime.Gosched()`.

### Мьютексы (`sync.Mutex`)

Мьютексы [[Mutexes]] используются для защиты общих ресурсов от одновременного доступа нескольких горутин.  Когда горутина пытается заблокировать мьютекс, который уже заблокирован, она блокируется и переходит в состояние ожидания.  Это также приводит к переключению контекста.

Мьютексы решают другую задачу (защита данных), но косвенно влияют на планирование горутин.

## Когда использовать `runtime.Gosched()`

`runtime.Gosched()` следует использовать с осторожностью. В большинстве случаев, использование каналов и других примитивов синхронизации (например, `sync.WaitGroup`, `sync.Mutex`) является более идиоматичным и эффективным способом управления параллелизмом в Go.

Однако, `runtime.Gosched()` может быть полезен в следующих ситуациях:

1.  **Длительные вычислительные задачи без блокирующих операций:** Как показано в примере выше, это помогает предотвратить "голодание" других горутин.
2.  **Тестирование:** `runtime.Gosched()` можно использовать в тестах для имитации различных сценариев планирования и проверки корректности работы параллельного кода.
3.  **Низкоуровневое программирование:** В редких случаях, когда требуется тонкий контроль над планированием горутин (например, при реализации собственных примитивов синхронизации).
4. **Взаимодействие с C кодом:** Если Go код вызывает функции C кода, которые могут выполняться долго и не взаимодействовать с планировщиком Go, то использование `runtime.Gosched()` может помочь избежать проблем.

## Заключение

`runtime.Gosched()` – это низкоуровневый инструмент, позволяющий явно взаимодействовать с планировщиком Go. Хотя в большинстве случаев его использование не требуется, он может быть полезен в специфических ситуациях, когда необходимо обеспечить честное распределение процессорного времени между горутинами или при тонкой настройке параллельного выполнения. Важно понимать, как работает `runtime.Gosched()`, и использовать его осознанно, предпочитая более высокоуровневые и идиоматичные средства Go, когда это возможно.

```old
`runtime.Gosched()` в Go - это функция из пакета `runtime`, которая используется для явного предоставления времени планировщику Go для перераспределения ресурсов горутин. Эта функция говорит планировщику Go, что текущая горутина готова отдать своё время выполнения другим горутинам.

Когда `runtime.Gosched()` вызывается внутри горутины, это дает возможность другим горутинам выполнить свою работу, что помогает предотвратить долгие блокировки или голодание горутин.

Вот пример использования `runtime.Gosched()`:

\`\`\`go
package main

import (
	"fmt"
	"runtime"
)

func main() {
	go func() {
		for i := 0; i < 3; i++ {
			fmt.Println("Goroutine 1")
			runtime.Gosched() // Предоставляем время другим горутинам
		}
	}()

	go func() {
		for i := 0; i < 3; i++ {
			fmt.Println("Goroutine 2")
			runtime.Gosched() // Предоставляем время другим горутинам
		}
	}()

	// Ждем завершения работы горутин
	fmt.Scanln()
}
\`\`\`

В этом примере две горутины печатают сообщения и вызывают `runtime.Gosched()`, чтобы предоставить время выполнения другим горутинам. Это помогает управлять доступом к ресурсам и улучшает параллельную обработку в программе.
```