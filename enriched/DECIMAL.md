#floatingPointArithmetic #go #python #javascript #programming #precision #binaryRepresentation #decimalRepresentation #comparison #equality

# Сравнение чисел с плавающей точкой в Go, Python и JavaScript

```table-of-contents
```

## Проблема неточного представления чисел с плавающей точкой

Предоставленный фрагмент кода демонстрирует распространенную проблему при работе с числами с плавающей точкой в различных языках программирования:

```go
num := 0.1 + 0.1 + 0.1
if num == 0.3 {
  fmt.Println("YES")
} else {
  fmt.Println("NO")
}
```

Ожидается, что результатом будет "NO", поскольку из-за особенностей представления чисел с плавающей точкой в двоичном формате (стандарт IEEE 754) точное представление десятичных дробей, таких как 0.1, невозможно.  Вместо этого они представляются с некоторой погрешностью. В Python и JavaScript этот код, скорее всего, выведет "NO". Однако, в Go, как утверждается, выводится "YES". Это утверждение *неверно* в общем случае.  Стандартный Go не использует никаких дополнительных библиотек по умолчанию для "точной" работы с числами с плавающей запятой, которые принципиально отличались бы от других языков в этом аспекте. Go, как и Python/Javascript, по умолчанию использует IEEE 754.

## Разбор ситуации и объяснение

1.  **Стандарт IEEE 754:** Большинство современных языков программирования, включая Go, Python и JavaScript, используют стандарт IEEE 754 для представления чисел с плавающей точкой. Этот стандарт определяет формат хранения чисел в двоичном виде, а также правила выполнения арифметических операций над ними.

2.  **Двоичное представление десятичных дробей:**  Десятичные дроби, такие как 0.1, не могут быть точно представлены в двоичной системе счисления.  Они превращаются в бесконечные периодические дроби.  Например:

    $0.1_{10} = 0.00011001100110011..._2$

    Поскольку компьютеры имеют ограниченный объем памяти, эти бесконечные дроби округляются до конечного числа разрядов, что приводит к небольшой погрешности.

3.  **Накопление погрешности:** При выполнении арифметических операций с числами с плавающей точкой погрешность может накапливаться.  В примере кода сложение 0.1 три раза приводит к накоплению погрешности, и результат может немного отличаться от 0.3.

4.  **Сравнение чисел с плавающей точкой:** Прямое сравнение чисел с плавающей точкой на равенство (==) часто приводит к неожиданным результатам из-за погрешностей представления. Вместо этого рекомендуется сравнивать числа с учетом некоторой допустимой погрешности (эпсилон).

## Корректное сравнение в Go, Python, и JavaScript

Вместо прямого сравнения `==` рекомендуется использовать сравнение с допуском.

**Go:**

```go
package main

import (
	"fmt"
	"math"
)

func almostEqual(a, b, epsilon float64) bool {
	return math.Abs(a-b) < epsilon
}

func main() {
	num := 0.1 + 0.1 + 0.1
	epsilon := 1e-9 // Задаем допустимую погрешность
	if almostEqual(num, 0.3, epsilon) {
		fmt.Println("YES")
	} else {
		fmt.Println("NO")
	}

	// Проверка стандартным сравнением
	if num == 0.3 {
        fmt.Println("YES (Direct comparison)")
    } else {
        fmt.Println("NO (Direct comparison)")
    }
}
```

В этом коде используется функция `almostEqual`, которая сравнивает два числа с плавающей точкой с учетом заданной погрешности `epsilon`.  `math.Abs` вычисляет абсолютное значение разности между двумя числами. Если это абсолютное значение меньше `epsilon`, числа считаются равными. Вывод этого кода, скорее всего, будет:

```
YES
NO (Direct comparison)
```

**Python:**

```python
import math

def almost_equal(a, b, epsilon=1e-9):
    return math.isclose(a, b, rel_tol=epsilon)

num = 0.1 + 0.1 + 0.1
if almost_equal(num, 0.3):
    print("YES")
else:
    print("NO")

# Проверка стандартным сравнением
if num == 0.3:
    print("YES (Direct comparison)")
else:
    print("NO (Direct comparison)")
```

В Python можно использовать функцию `math.isclose` (появилась в Python 3.5), которая выполняет аналогичное сравнение. Параметр `rel_tol` задает относительную погрешность.

**JavaScript:**

```javascript
function almostEqual(a, b, epsilon = 1e-9) {
  return Math.abs(a - b) < epsilon;
}

const num = 0.1 + 0.1 + 0.1;
if (almostEqual(num, 0.3)) {
  console.log("YES");
} else {
  console.log("NO");
}

// Проверка стандартным сравнением
if (num == 0.3) {
    console.log("YES (Direct comparison)")
} else {
    console.log("NO (Direct comparison)")
}
```

В JavaScript можно определить свою функцию `almostEqual`, аналогичную той, что используется в Go.

## Вывод и альтернативные решения

Утверждение, что Go по-умолчанию дает "YES" при прямом сравнении `0.1 + 0.1 + 0.1 == 0.3`, не соответствует действительности. Go ведёт себя так же, как и другие языки, использующие стандарт IEEE 754. Для корректного сравнения чисел с плавающей точкой необходимо использовать сравнение с допуском.

**Альтернативные подходы (для специфических случаев):**

*   **Использование целочисленной арифметики:** Если важна абсолютная точность и известны диапазоны значений, можно умножить числа на некоторый коэффициент (например, 1000), чтобы перейти к целым числам, выполнить операции, а затем разделить результат обратно. Это подходит, например, для финансовых расчетов.

*   **Библиотеки для работы с десятичными числами:** В некоторых языках существуют библиотеки, которые предоставляют тип данных "десятичное число" (Decimal), который хранит числа в десятичном формате и позволяет выполнять операции с ними без потери точности, характерной для двоичных чисел с плавающей точкой.  В Go это, например, `shopspring/decimal`. В Python - `decimal`. В JavaScript - `decimal.js`.

    **Пример для Go (shopspring/decimal):**

    ```go

    import (
        "fmt"
        "github.com/shopspring/decimal"
    )

    func main() {
        num1, _ := decimal.NewFromString("0.1")
        num2, _ := decimal.NewFromString("0.1")
        num3, _ := decimal.NewFromString("0.1")
	    num4, _ := decimal.NewFromString("0.3")
        sum := num1.Add(num2).Add(num3)

        if sum.Equal(num4) {
            fmt.Println("YES")
        } else {
            fmt.Println("NO")
        }
        fmt.Println(sum)
    }
    ```
    Этот код выведет "YES", так как используется десятичная арифметика.
* [[BigDecimal]]
* [[IEEE 754]]
* [[Floating-point arithmetic]]

```old
Код выдаёт "YES" в отличии от Python и JavaScript

\`\`\`go
num := 0.1 + 0.1 + 0.1
if num == 0.3 {
  print("YES")
} else {
  print("NO")
}
\`\`\`

Это связано с тем, как числа с плавающей запятой представлены и обрабатываются в разных языках программирования.

В Python и JavaScript числа с плавающей запятой представлены в формате двоичной системы счисления, что может привести к неточностям при представлении некоторых десятичных дробей. Например, 0.1 в двоичной системе счисления является бесконечной дробью, поэтому она не может быть точно представлена. Это приводит к тому, что сумма 0.1 + 0.1 + 0.1 не равна 0.3.

В Go, с другой стороны, используется библиотека для точной работы с числами с плавающей запятой, которая может обеспечить более точные результаты для таких операций. Ваш код на Go дает “YES”, потому что Go обрабатывает эту ситуацию иначе, чем Python и JavaScript.
```