#determinism #workflow #temporal #orchestration #cadence #distributed_systems #fault_tolerance #stateful #replay #golang

# Determinism, Workflow + Temporal

```table-of-contents
```

## Введение в Temporal и оркестрацию рабочих процессов

Temporal - это платформа для оркестрации распределенных рабочих процессов, которая обеспечивает надежное выполнение кода, написанного разработчиком. Она решает проблемы, связанные с управлением состоянием, обработкой ошибок и масштабированием в распределенных системах. Существует несколько подходов к оркестрации:

1.  **BPM (Business Process Management)**:
    *   Инструменты, такие как Camunda и Zeebe, используют графические редакторы для определения рабочих процессов.
    *   Подходят для бизнес-процессов, где важна визуализация и участие нетехнических специалистов.
2.  **DSL (Domain Specific Language)**:
    *   Conductor и Yandex.Procaas используют DSL для описания рабочих процессов.
    *   Предоставляют более гибкий подход, чем BPM, но требуют изучения специфического языка.
3.  **Code**:
    *   Cadence и Temporal позволяют описывать рабочие процессы непосредственно в коде (например, на Go).
    *   Обеспечивают максимальную гибкость и контроль над выполнением, но требуют больше усилий от разработчиков.

Temporal, как представитель подхода "Code", предлагает модель "Workflow As Code".

## Workflow As Code

"Workflow As Code" означает, что рабочий процесс определяется как программа, которая:

*   **Отказоустойчива**: Temporal гарантирует, что рабочий процесс будет выполнен, даже если произойдут сбои в системе.
*   **Выполняет задачи**: Рабочий процесс состоит из отдельных задач (Activities), которые выполняют конкретные действия (например, вызов внешнего API, обработка данных).
*   **Реагирует на внешние события**: Рабочий процесс может ожидать внешних событий (сигналов), таймеров и таймаутов.

![](./assets/temporal/workflow-as-code.png)

![](./assets/temporal/workflow-cut.png)

## Stateful Execution Model

Ключевой особенностью Temporal является его модель выполнения с сохранением состояния. Она включает в себя два основных компонента:

*   **Workflow Function**: Это код, написанный на Go с использованием Temporal SDK, который определяет логику рабочего процесса. Он описывает последовательность действий, обработку событий и реакцию на таймеры.
*  **Workflow Execution**: Это экземпляр выполнения Workflow Function на стороне Temporal. Temporal отслеживает состояние выполнения, обрабатывает сбои и обеспечивает надежное выполнение кода.

![](./assets/temporal/stateful-execution-model.png)

### Replay

Для обеспечения отказоустойчивости Temporal использует механизм **Replay**. Когда рабочий процесс должен быть возобновлен (например, после сбоя), Temporal "переигрывает" историю событий, чтобы восстановить состояние рабочего процесса. Во время повтора сгенерированные команды (вызовы Activities, таймеры и т.д.) проверяются на соответствие существующей истории событий. Это гарантирует, что рабочий процесс продолжит выполнение с того места, где он остановился, и что его поведение будет детерминированным.

![](./assets/temporal/event-log.png)

## Inversion Of Execution

Traditional execution model:

1.  **Your code** calls external services.
2.  **Your code** handles errors and retries.

Temporal inversion of execution:

1.  **Temporal** calls your code (Activities).
2.  **Temporal** handles errors, retries, and state management.

![](./assets/temporal/inversion-of-execution.png)

## Order Management System (Пример)

Рассмотрим пример системы управления заказами, построенной с использованием Temporal.

![](./assets/temporal/order-management-system.png)

В этом примере рабочий процесс управляет всем жизненным циклом заказа, от создания до доставки. Он включает в себя такие шаги, как обработка платежа, проверка наличия товара, организация доставки и уведомление клиента. Temporal обеспечивает надежное выполнение всех этих шагов, даже если происходят сбои в отдельных сервисах.

Важно отметить, что разработчики системы управления заказами в примере используют ElasticSearch. Они отмечают, что "Elastic - альтернатив нет; позволяет индексировать workflow и делать выборки из него, что очень полезно для нашей админки, для саппорта". Это демонстрирует возможность интеграции Temporal с другими инструментами для мониторинга и управления рабочими процессами.

## Use the State, Luke (Использование состояния)

Рассмотрим проблему поддержки консистентности данных при использовании Temporal.

![](./assets/temporal/two-db.png)

Проблема: Как обеспечить атомарность операций, затрагивающих как состояние Workflow (в Temporal), так и внешнюю базу данных?

**Неправильный подход**: Использовать две отдельные транзакции (одну для Temporal, другую для внешней БД). Это может привести к рассинхронизации данных, если одна из транзакций завершится неудачно.

![](./assets/temporal/use-state.png)

**Плохой подход**: Выполнять операции с внешней БД внутри Workflow Function. Это нарушает детерминизм, так как внешние вызовы могут иметь побочные эффекты и приводить к разным результатам при повторном выполнении.

![](./assets/temporal/true-way.png)

**Правильный подход**: Использовать Activities для взаимодействия с внешней БД. Activities выполняются вне контекста Workflow Function и не влияют на его детерминизм. Temporal гарантирует, что Activity будет выполнена (или повторена в случае сбоя) и что ее результат будет сохранен в истории событий.

## Polling Activity

![](./assets/temporal/polling-activity.png)

Разработчики Temporal **не рекомендуют** поллить чаще, чем с периодом в 1 минуту.

![](./assets/temporal/high-freq-activity.png)
![](./assets/temporal/low-freq-activity.png)

## Signal is not Promise (Сигналы)

![](./assets/temporal/signal-is-not-promise.png)

Temporal гарантирует доставку сигнала до Workflow. Однако, изменения, которые произойдут в состоянии Workflow в результате обработки сигнала, не могут быть определены синхронно.

![](./assets/temporal/signal-is-not-promise-code.png)

## Workflow Not-Determinism (Недетерминизм рабочего процесса)

![](./assets/temporal/workflow-not-determinism.png)

Детерминизм Workflow Function является критически важным аспектом Temporal. Это означает, что при одних и тех же входных данных (истории событий) Workflow Function всегда должна выдавать один и тот же результат (последовательность команд). Нарушение детерминизма может привести к непредсказуемому поведению рабочего процесса и проблемам при его повторном выполнении.

### Как избежать недетерминизма?

1.  **Версионирование**: Используйте механизм версионирования Temporal для управления изменениями в коде Workflow Function. Это позволяет безопасно обновлять код, не нарушая работу существующих экземпляров рабочего процесса.
    ![](./assets/temporal/workflow-not-determinism-version.png)
2.  **`workflowcheck`**: Используйте инструмент `workflowcheck` из Temporal SDK для статического анализа кода Workflow Function на предмет потенциальных проблем с детерминизмом.

3.  **Replay-тесты**: Пишите тесты, которые проверяют детерминизм Workflow Function путем "переигрывания" истории событий.
    ![](./assets/temporal/workflow-not-determinism-replay-test.png)
4.  **Side Effects**: Используйте `Side Effects` для выполнения недетерминированной логики (например, генерации случайных чисел, получения текущего времени). `Side Effects` гарантируют, что результат выполнения будет записан в историю событий и использован при повторном выполнении.
5.  **Правильные конструкции Go**: Используйте только те конструкции языка Go, которые гарантированно являются детерминированными в контексте Temporal.

    ![](./assets/temporal/workflow-not-determinism-true-go.png)

### Как локализовать недетерминизм?

1.  **Replay-тесты и дебаггер**: Выгрузите проблемный Workflow и прогоните его через replay-тест с помощью дебаггера. Это позволит пошагово отследить выполнение кода и выявить место, где нарушается детерминизм.
2.  **Стек-трейсы в UI Temporal**: Изучайте стек-трейсы в UI Temporal, чтобы получить информацию о том, какие вызовы привели к ошибке недетерминизма.

    ![](./assets/temporal/workflow-not-determinism-fuckup.png)

## Fail State

Если Workflow Function не может быть завершена с ошибкой, а Activity не может быть выполнена успешно, то Workflow переходит в состояние Fail.

### Причины Fail State

*   Проблема во внешней системе, с которой взаимодействует Activity.
*   Ошибка в исходных данных, переданных в Workflow.
*   Невалидные данные, полученные от внешней системы.

### Решения для Fail State

*   **Бесконечные попытки отправки**: Activity может быть настроена на бесконечное повторение в случае сбоя. Это может быть полезно, если проблема во внешней системе является временной.
*   **Редактирование исходных данных**: Предоставьте возможность пользователю отредактировать исходные данные, если они являются причиной сбоя.
*   **Ручное повторение Activity**: Дайте возможность оператору вручную повторить выполнение Activity.
*   **Эскалация в службу поддержки**: Если проблему не удается решить автоматически или с помощью оператора, эскалируйте ее в службу поддержки.
* **Не сразу завершать workflow**: Не завершать workflow при ошибке, а давать возможность решить проблему.

DataDog помогает мониторить Fail State.

## Синхронный workflow

![](./assets/temporal/sync-workflow.png)

Компромисс между скоростью и возможностью компенсаций. Можно использовать сигналы для реализации синхронного поведения, но это усложняет логику и может привести к проблемам с производительностью.

## Заключение: Что же такое Temporal?

*   **Гарантия исполнения**: Temporal гарантирует, что рабочий процесс будет выполнен, даже если произойдут сбои.
*   **Нагрузка на DB**: Temporal активно использует базу данных для хранения состояния рабочих процессов, что может привести к высокой нагрузке на БД.
*   **Парадигма программирования**: Temporal предлагает новую парадигму программирования распределенных систем, основанную на концепции рабочих процессов.
*   **Фреймворк/SDK**: Temporal предоставляет фреймворк и SDK для разработки и управления рабочими процессами.
*   **Транспорт**: Temporal использует сигналы для взаимодействия между рабочими процессами и внешними системами, вместо традиционных gRPC/HTTP вызовов.
*   **Не про realtime**: Temporal не предназначен для обработки событий в реальном времени. Он ориентирован на длительные, асинхронные операции.
*   **Комьюнити**: Temporal имеет активное сообщество разработчиков, которое предоставляет поддержку и развивает платформу.

```old
# [Determinism, Wokrflow + Temporal](https://www.youtube.com/watch?v=YfWu5swj-Gg)

## Виды окрестрации

- BPM
  - Camunda
  - Zeebe
- DSL
  - Conductor
  - Yandex.Procaas
- Code
  - Cadence
  - Temporal

**Temporal - это масштабируемая распределённая платформа оркестрации рабочих процессов**

## Workflow As Code

Определение рабочего процесса:

- Отказоустойчивая программа
- Выполняющая задачи
- Реагирующая на внешние события, включая
- Таймеры и таймауты

![](./assets/temporal/workflow-as-code.png)
![](./assets/temporal/workflow-cut.png)

## Stateful Execution Model

- **Workflow Function** - код, написанный на Go, который описывает работу Workflow с использованием Temporal SDK
- **Workflow Execution** - выполнение Workflow на стороне Temporal, который обеспечивает надёжное выполнение Workflow Function

![](./assets/temporal/stateful-execution-model.png)

**Replay** - это метод, с помощью которого выполение рабочего процесса возобновляет выполение. Во время повтора сгенерированные команды проверяются на соответсвие существующей истории событий.

![](./assets/temporal/event-log.png)

## Inversion Of Execution

![](./assets/temporal/inversion-of-execution.png)

## Order Management System

![](./assets/temporal/order-management-system.png)

"Elastic - альтернатив нет; позволяет индексировать workflow и делать выборки из него, что очень полезно для нашей админки, для саппорта".

## Use the State, Luke

![](./assets/temporal/two-db.png)

![](./assets/temporal/use-state.png)

![](./assets/temporal/true-way.png)

## Polling Activity

![](./assets/temporal/polling-activity.png)

Разработчики Temporal не рекомендуют поллить чаще, чем с периодом в 1 минуту.

![](./assets/temporal/high-freq-activity.png)

![](./assets/temporal/low-freq-activity.png)

## Signal is not Promise

![](./assets/temporal/signal-is-not-promise.png)

Temporal гарантирует отправку сигнала. Но какие изменения произойдут в state - синхронно узнать невозможно.

![](./assets/temporal/signal-is-not-promise-code.png)

## Workflow Not-Determinism

![](./assets/temporal/workflow-not-determinism.png)

### Как недопустить?

- Версионировать
- Использовать [workflowcheck](https://pkg.go.dev/go.temporal.io/sdk/contrib/tools/workflowcheck)
- Использовать replay-тесты
- Использовать Side Effects для недетерминированной логики
- Использовать _правильные конструкции_ GoLang

![](./assets/temporal/workflow-not-determinism-version.png)

![](./assets/temporal/workflow-not-determinism-replay-test.png)

![](./assets/temporal/workflow-not-determinism-true-go.png)

### Как локализовать?

- Выгрузить проблемный workfow, и прогнать его через replay-тест с помощью дебагера
- Изучать стек-трейсы в UI Temporal

![](./assets/temporal/workflow-not-determinism-fuckup.png)

## Fail State

Если workflow нельзя завершить ошибкой, а activity не может выполниться успешно, то workflow переходит в Fail State.

### Как такое возможно?

- Проблема во внешней системе
- Ошибка в исходных данных
- Невалидные данные из внешней системы

### А как решать?

- Бесконечные попытки отправки
- Возможность отредактировать исходные данные
- Ручное повторение активити
- Эскалация в саппорт
- Не сразу завершать workflow

DataDog помогает мониторить

## Синхронный workflow

![](./assets/temporal/sync-workflow.png)

компромисс между скоростью и возможностью компенсаций

## Что же такое Temporal?

- Гарантия исполнения
- Огромная нагрузка на DB
- Парадигма программирования
- Фреймворк/SDK
- Транспорт (сигналы вместо gRPC/HTTP ручек)
- Не про realtime
- Комьюнити

```