#receiverTypesMixing #go #golang #methods #receivers #pointers #values #time #immutability #interfaces #compatibility

# Смешивание типов получателей в Go

```table-of-contents
```

## Обзор проблемы

В языке Go существует концепция методов, которые привязываются к определенному типу (получателю). Получатель может быть двух видов: по значению (value receiver) и по указателю (pointer receiver). Возникает вопрос: допустимо ли в рамках одного типа смешивать эти два вида получателей? То есть, могут ли одни методы одного и того же типа иметь получатель-значение, а другие – получатель-указатель?

## Общая рекомендация и исключения

В целом, смешивание типов получателей считается плохой практикой и не рекомендуется. Это связано с тем, что такое смешивание может привести к неожиданному поведению и сложностям в понимании кода. Однако, существуют исключения, и одним из ярких примеров является стандартная библиотека Go, а именно структура `time.Time`.

## Пример `time.Time`

Разработчики Go стремились сделать структуру `time.Time` неизменяемой (immutable). Поэтому большинство методов этой структуры, такие как `After`, `IsZero`, `UTC` и другие, используют получатель-значение. Это гарантирует, что вызов этих методов не изменит исходное значение `time.Time`.

Однако, для обеспечения совместимости с интерфейсом `encoding.TextUnmarshaler`, структура `time.Time` должна реализовать метод `UnmarshalBinary([]byte) error`. Этот метод, по своей сути, *изменяет* получатель, основываясь на данных из байтового среза. Следовательно, `UnmarshalBinary` использует получатель-указатель.

Этот пример демонстрирует, что, хотя смешивание типов получателей в целом не приветствуется, оно не запрещено абсолютно во всех случаях. Иногда это может быть необходимо для обеспечения совместимости или реализации определенной функциональности.

## Влияние на реализацию интерфейсов

Смешивание типов получателей напрямую влияет на то, как тип реализует интерфейсы. Рассмотрим несколько примеров.

**Пример 1: Смешивание и невозможность использования значения как интерфейса**

```go
package main

type IA interface {
	B()
	C()
}

type A struct{}

func (A) B()  {}  // Метод B с получателем-значением
func (*A) C() {} // Метод C с получателем-указателем

func main() {
	var a IA
	a = A{} // cannot use A{} (value of type A) as IA value
	_ = a
}
```

В этом примере, тип `A` имеет два метода: `B` с получателем-значением и `C` с получателем-указателем. Интерфейс `IA` требует наличия обоих методов. Однако, при попытке присвоить значение типа `A` переменной типа `IA`, компилятор выдаст ошибку. Это происходит потому, что значение типа `A` не реализует метод `C` интерфейса `IA` (т.к. `C` имеет *pointer receiver*). Чтобы исправить ошибку, необходимо присваивать переменной `a` *указатель* на `A`: `a = &A{}`.

**Пример 2: Все методы с получателем-значением или все с получателем-указателем**

```go
package main

type IA interface {
	B()
	C()
}

type A struct{}

func (A) B()  {}
func (A) C() {}

type PA struct{}

func (*PA) B() {}
func (*PA) C() {}

func main() {
	var a, pa IA
	a = A{}
	pa = &PA{}
	_ = a
	_ = pa
}
```

В этом примере показаны два типа: `A` (все методы с получателями-значениями) и `PA` (все методы с получателями-указателями). Оба типа успешно реализуют интерфейс `IA`. Значение типа `A` может быть присвоено переменной типа `IA`, а указатель на `PA` – переменной типа `IA`.

**Пример 3: Обход ограничений с помощью разделения интерфейсов**
```go
package main

type IA interface {
	C()
}

type IB interface {
	D()
}

type A struct{}

func (A) C()  {}
func (*A) D() {}

func main() {
	var a IA
	a = A{}
	var pb IB
	pb = &A{}
	_ = a
	_ = pa
}
```
Этот код компилируется и работает без ошибок. Здесь используется "разделение" интерфейсов:

*   `IA` требует только метод `C()`, который у типа `A` реализован с получателем-значением.
*   `IB` требует только метод `D()`, который у типа `A` реализован с получателем-указателем.

Таким образом, мы можем использовать как значение `A` (для `IA`), так и указатель на `A` (для `IB`), обходя ограничение, связанное со смешиванием типов получателей в рамках одного интерфейса.

## Подробное объяснение и обоснование

**Почему смешивание типов получателей в целом не рекомендуется?**

1.  **Неоднозначность и путаница:** Когда одни методы изменяют объект (pointer receiver), а другие нет (value receiver), это может привести к путанице и усложнить понимание того, как работает код. Разработчику нужно постоянно помнить, какой тип получателя используется в каждом конкретном методе.

2.  **Неожиданное поведение:**  Если вы привыкли работать с методами, которые не изменяют объект (value receiver), вы можете случайно вызвать метод с pointer receiver, который *изменит* объект, что приведет к неожиданным последствиям.

3. **Сложность в поддержке и отладке:**  Код, в котором смешаны типы получателей, сложнее поддерживать и отлаживать.

**Почему в `time.Time` сделано исключение?**

Исключение для `time.Time` обусловлено балансом между желанием сделать структуру неизменяемой и необходимостью реализовать стандартный интерфейс `encoding.TextUnmarshaler`.

*   **Неизменяемость:**  Использование value receiver для большинства методов гарантирует, что операции с датой и временем (сравнение, получение компонентов и т.д.) не изменят исходное значение. Это важно для предотвращения ошибок и обеспечения предсказуемости поведения.

*   **Совместимость:**  Интерфейс `encoding.TextUnmarshaler` требует наличия метода `UnmarshalBinary`, который по своей природе *изменяет* объект. Чтобы соответствовать этому интерфейсу, метод `UnmarshalBinary` в `time.Time` вынужден использовать pointer receiver.

**Подробное объяснение примеров с интерфейсами**

Примеры с интерфейсами демонстрируют, как Go обрабатывает типы и методы с разными типами получателей при работе с интерфейсами.

Ключевой момент: интерфейс в Go – это контракт. Тип реализует интерфейс, если он имеет *все* методы, объявленные в интерфейсе, с *соответствующими* типами получателей.

*   Если метод в интерфейсе объявлен с value receiver, то тип должен иметь этот метод с value receiver.
*   Если метод в интерфейсе объявлен с pointer receiver, то тип должен иметь этот метод с pointer receiver.

В первом примере (`a = A{}`) ошибка возникает потому, что значение типа `A` не имеет метода `C` с *pointer receiver*.  С точки зрения интерфейса `IA`, у значения `A` просто нет метода `C`. Однако, *указатель* на `A` (`&A{}`) имеет оба метода: `B` (унаследованный от значения `A`) и `C` (определенный для указателя).

## Заключение

Смешивание типов получателей (value receiver и pointer receiver) в Go – это практика, которой следует избегать, за исключением случаев, когда это действительно необходимо (например, для совместимости с интерфейсами). Хотя технически это возможно, такое смешивание может привести к путанице, неожиданному поведению и сложностям в поддержке кода. Пример `time.Time` показывает, что иногда исключения оправданы, но они должны быть тщательно продуманы и обоснованы. При работе с интерфейсами важно помнить, что тип должен иметь все методы интерфейса с соответствующими типами получателей, чтобы считаться реализующим этот интерфейс.

```old
**Смешивание типов получателей**

Можно ли смешивать типы получателей, например, в структуре, содержащей не- сколько методов, где некоторые содержат получатели указателя, а другие — по- лучатели значения? Общее мнение таково, что это следует запретить. Но в стан- дартной библиотеке есть контрпримеры, например time.Time.

Разработчики хотели обеспечить неизменяемость структуры time.Time. Сле- довательно, большинство методов, таких как After, IsZero и UTC, имеют полу- чатели значения. Но для совместимости с существующими интерфейсами — encoding.TextUnmarshaler — структура time.Time должна реализовать метод UnmarshalBinary([]byte)error, который изменяет получатель, задаваемый байтовым срезом. Этот метод имеет получатель указателя.

В целом следует избегать смешивания типов получателей, но это не запрещено в 100 % случаев.

\`\`\`go
package main

type IA interface {
	B()
	C()
}

type A struct{}

func (A) B()  {}
func (*A) C() {}

func main() {
	var a IA
	a = A{} // cannot use A{} (value of type A) as IA value
	_ = a
}
\`\`\`

Если будешь смешивать приёмники, то так не сделаешь:

\`\`\`go
package main

type IA interface {
	B()
	C()
}

type A struct{}

func (A) B()  {}
func (A) C() {}

type PA struct{}

func (*PA) B() {}
func (*PA) C() {}

func main() {
	var a, pa IA
	a = A{}
	pa = &PA{}
	_ = a
	_ = pa
}
\`\`\`

Хотя можно обмануть судьбу разделением интерфейсов 🙃

\`\`\`go
package main

type IA interface {
	C()
}

type IB interface {
	D()
}

type A struct{}

func (A) C()  {}
func (*A) D() {}

func main() {
	var a IA
	a = A{}
	var pb IB
	pb = &A{}
	_ = a
	_ = pb
}
\`\`\`

```