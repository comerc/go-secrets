#golang #generics #type_constraints #tilde #interface #custom_types #programming #go #go_1_18 #go_1_21

# Ограничения типов и тильда в Go Generics

```table-of-contents
```

## Введение в дженерики и ограничения типов

Дженерики (обобщенное программирование) были добавлены в Go, начиная с версии 1.18. Они позволяют писать функции и структуры данных, которые могут работать с различными типами, не теряя при этом типобезопасности на этапе компиляции. Ключевым аспектом дженериков являются ограничения типов (type constraints). Ограничения типов определяют, какие именно типы могут быть использованы в качестве аргументов типа для обобщенной функции или типа.

## Роль интерфейсов в ограничениях типов

В Go ограничения типов реализуются через интерфейсы. Интерфейс в контексте ограничений типов может содержать не только список методов, но и список типов.  Это позволяет указать, что обобщенный тип должен быть одним из перечисленных типов или реализовывать определенные методы.

Пример интерфейса с методами (классический случай):

```go
type Stringer interface {
    String() string
}

func PrintString[T Stringer](s T) {
    fmt.Println(s.String())
}
```

В этом примере `PrintString` может принимать любой тип `T`, который реализует интерфейс `Stringer`, то есть имеет метод `String()`.

Пример интерфейса с перечислением типов (для ограничений):

```go
type Number interface {
    int | int64 | float32 | float64
}

func Sum[T Number](a, b T) T {
    return a + b
}
```

Здесь `Sum` может принимать только типы, перечисленные в интерфейсе `Number`.

## Проблема с пользовательскими типами

Рассмотрим следующий пример:

```go
type MyInt int

type Number interface {
    int | int64
}

func Add[T Number](a, b T) T {
    return a + b
}

func main() {
    var x, y MyInt = 5, 10
    // fmt.Println(Add(x, y)) // Ошибка компиляции
}
```

Этот код не скомпилируется, потому что `MyInt`, хотя и основан на `int`, не является непосредственно типом `int`.  `MyInt` - это отдельный, новый тип. Интерфейс `Number` явно указывает `int` и `int64`, но не `MyInt`.

## Решение с помощью тильды (~)

Для решения этой проблемы в Go 1.18 был введен оператор тильды (`~`). Тильда перед типом в ограничении типа означает "любой тип, базовым типом которого является указанный тип".

Изменим предыдущий пример:

```go
type MyInt int

type Number interface {
    ~int | ~int64
}

func Add[T Number](a, b T) T {
    return a + b
}

func main() {
    var x, y MyInt = 5, 10
    fmt.Println(Add(x, y)) // Работает!
}
```

Теперь `Number` включает в себя не только `int` и `int64`, но и любые типы, "основанные" на них. `MyInt`, базовым типом которого является `int`, теперь удовлетворяет ограничению `Number`.

## Подробное объяснение работы тильды

Тильда (`~`) в Go generics указывает на *подлежащий тип* (underlying type). Когда вы определяете новый тип на основе существующего (например, `type MyInt int`), `MyInt` становится новым, отличным типом с теми же базовыми характеристиками, что и `int` (те же операции, то же представление в памяти), но это *разные* типы с точки зрения системы типов Go.

Без тильды ограничение типа строго соответствует перечисленным типам. С тильдой ограничение включает в себя все типы, чьим *подлежащим типом* является указанный.

Рассмотрим подробнее понятие [[подлежащего типа]]. Подлежащий тип – это тип, на основе которого создан пользовательский тип. Если у нас есть `type MyInt int`, то подлежащим типом `MyInt` является `int`. Если бы у нас было `type MyCustomString string`, то подлежащим типом `MyCustomString` был бы `string`. Это относится и к более сложным типам: если `type MySlice []int`, то подлежащим типом `MySlice` будет `[]int`.

## Примеры использования

**Пример 1: Обобщенная функция для числовых типов**

```go
type Numeric interface {
	~int | ~int8 | ~int16 | ~int32 | ~int64 |
		~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
		~float32 | ~float64 |
		~complex64 | ~complex128
}

func Multiply[T Numeric](a, b T) T {
	return a * b
}

type MyCustomInt int

func main() {
	var a MyCustomInt = 5
	var b MyCustomInt = 10
	fmt.Println(Multiply(a, b)) // Выведет 50

	var c int = 7
	var d int = 3
	fmt.Println(Multiply(c, d)) // Выведет 21
}

```

В этом примере `Numeric` определяет интерфейс, который включает все числовые типы Go, а также любые пользовательские типы, основанные на них. Функция `Multiply` может работать с любыми из этих типов.

**Пример 2: Работа со структурами**
```go
type MyBaseType struct {
	Value int
}

type MyDerivedType MyBaseType

type BaseInterface interface {
	~struct{ Value int }
}

func PrintValue[T BaseInterface](val T) {
     // Нельзя напрямую обратиться к Value
     // fmt.Println(val.Value)
     // Но можно через reflect или интерфейсы, если добавить методы
     // В данном случае покажем, что тип подходит, но прямого доступа к полям нет
	fmt.Printf("%T\n", val)
}

func main() {
	mb := MyBaseType{Value: 10}
	md := MyDerivedType{Value: 20}

	PrintValue(mb) // MyBaseType
	PrintValue(md) // MyDerivedType
}

```
Важно отметить: тильда работает только с базовыми типами. Нельзя написать `~[]int` или `~map[string]int`. Это связано с тем, как Go обрабатывает подлежащие типы. `[]int` или `map[string]int` сами по себе являются базовыми типами. У них нет "подлежащего" типа, отличного от них самих.

**Пример 3: Ограничение на определенное поведение.**

Предположим, мы хотим создать функцию, которая сортирует слайсы. Мы могли бы использовать `sort.Interface`, но это потребовало бы от пользователя реализовать методы `Len`, `Less` и `Swap`.  Вместо этого мы можем создать своё ограничение, используя тильду:

```go

type MyInt int

func (m MyInt) Less(other MyInt) bool {
	return m < other
}

type Lessable interface {
	Less(other Self) bool
}

type Self interface {
	~int | Lessable
}

//func SortSlice[T constraints.Ordered](slice []T) { // constraints.Ordered уже включает в себя тильду.
//	sort.Slice(slice, func(i, j int) bool {
//		return slice[i] < slice[j]
//	})
//}

func SortSlice[T Self](slice []T) {
	// Пузырьковая сортировка для примера, на практике лучше использовать sort.Slice
	n := len(slice)
	for i := 0; i < n-1; i++ {
		for j := 0; j < n-i-1; j++ {
			// Используем Less, если T реализует Lessable, иначе предполагаем, что это int и используем <
			if lessable, ok := any(slice[j]).(Lessable); ok {
				if lessable2, ok2 := any(slice[j+1]).(Lessable); ok2 {
					if lessable.Less(lessable2) {
						slice[j], slice[j+1] = slice[j+1], slice[j]
					}
				}

			} else { // предполагаем int
				if slice[j] > slice[j+1] {
					slice[j], slice[j+1] = slice[j+1], slice[j]
				}
			}
		}
	}
}

func main() {
	myInts := []MyInt{5, 2, 8, 1, 9, MyInt(4)} // Явное привидение 4 к MyInt
	SortSlice(myInts)
	fmt.Println(myInts) // Вывод: [1 2 4 5 8 9]

	ints := []int{5, 2, 8, 1, 9, 4}
	SortSlice(ints)
	fmt.Println(ints) // Вывод: [1 2 4 5 8 9]

}
```

В этом примере, `SortSlice` работает как со встроеным типом int, так и с пользовательским типом `MyInt`, потому что `MyInt` определен с подлежащим типом `int` и реализует метод Less.

## Плюсы и минусы использования тильды

**Плюсы:**

*   **Гибкость:** Тильда позволяет создавать более гибкие ограничения типов, которые охватывают не только конкретные типы, но и все производные от них.
*   **Удобство:**  Разработчикам не нужно явно указывать все возможные пользовательские типы в ограничениях.
*   **Сокращение кода:**  Меньше дублирования кода, связанного с определением ограничений типов.

**Минусы:**

*   **Меньшая строгость:**  Тильда делает ограничения типов менее строгими. Это может привести к неожиданному поведению, если не быть внимательным к тому, какие типы удовлетворяют ограничению.
* **Сложность чтения:** Код с тильдой может быть сложнее для чтения и понимания, особенно для тех, кто не знаком с этой концепцией.
* **Ограничения на структуры:** Тильда сработает для структуры, но не позволит напрямую обращаться к полям структуры.

## Альтернативные решения

В некоторых случаях вместо тильды можно использовать другие подходы:

1.  **Интерфейсы с методами:** Если важна не структура типа, а его поведение, лучше использовать интерфейсы с методами. Это обеспечивает большую гибкость и явное определение контракта.

2.  **Пакет `constraints`:** В стандартной библиотеке Go есть пакет `constraints`, который предоставляет предопределенные ограничения для распространенных типов, таких как `constraints.Ordered` (для типов, поддерживающих операторы сравнения) и `constraints.Integer` (для целочисленных типов).  Эти ограничения уже включают тильду.

3.  **Рефлексия (reflect):** Пакет `reflect` позволяет работать с типами и значениями во время выполнения. Его можно использовать для доступа к полям структур, но это менее эффективно и типобезопасно, чем дженерики.

4.  **Type assertions (приведение типов):** Можно использовать приведение типов внутри обобщенной функции, но это также менее типобезопасно и может привести к ошибкам времени выполнения.

Выбор конкретного подхода зависит от задачи и требований к коду. Тильда – мощный инструмент, но его следует использовать с осторожностью, понимая его преимущества и недостатки.

## Заключение

Тильда (`~`) в ограничениях типов Go generics – это важный механизм, позволяющий работать с пользовательскими типами, основанными на базовых типах. Она делает дженерики более гибкими и удобными в использовании, но требует внимательного отношения к определению ограничений типов. Понимание принципов работы тильды и подлежащих типов необходимо для эффективного использования дженериков в Go.

```old
`type Number interface { ~int | ~int8 }` - допускает "кастомный" тип для дженериков: `func Fn[T Number](a T) {};` "~" нужна для наследников `int`, например: `type MyInt int`


\`\`\`go
type MyBase interface {
	// int32 | int64 // так не работает sum() для MyCustomType
  ~int32 | ~int64
}

type MyCustomType int32

func sum[T MyBase](a, b T) T {
	return a + b
}

func main() {
	var a, b MyCustomType = 1, 2 // применяю MyCustomType для sum()

	println(sum(a, b))
}

\`\`\`
```