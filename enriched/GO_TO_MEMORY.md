#go #testing #benchmarking #memory #allocation #pointers #optimization #performance #structs #golang

# Оптимизация выделения памяти в Go на примере структуры с указателем

```table-of-contents
```

## Анализ предоставленного кода и постановка задачи

Предоставленный код на Go демонстрирует два способа инициализации структуры `X`, содержащей указатель на целое число `p`. Первый способ (в коде закомментирован, как более медленный) создает структуру и поле-указатель одновременно. Второй способ (более быстрый) сначала создает указатель, затем структуру и присваивает поле указатель на созданную переменную. Задача состоит в том, чтобы подробно объяснить, почему второй способ быстрее, какие механизмы Go задействованы, и как это связано с выделением памяти.  Так же необходимо предложить альтернативные решения, если таковые имеются, и рассмотреть их с точки зрения производительности.

## Детальное объяснение различий в производительности

Разница в производительности между двумя подходами связана с тем, как Go управляет памятью и как компилятор оптимизирует код. Рассмотрим каждый подход по шагам:

**Первый подход (медленный):**

1.  `var i2 int`: Выделяется память под целое число `i2` на стеке. Это быстрая операция.
2.  `x2 := &X{}`: Выделяется память под структуру `X` на куче ([[Heap Allocation]]). Это более медленная операция, чем выделение на стеке. Причина в том, что куча - это динамически управляемая область памяти, и выделение в ней требует больше накладных расходов (поиск свободного блока, синхронизация доступа и т.д.).
3.  `x2.p = &i2`: Полю `p` структуры `x2` присваивается адрес переменной `i2`.

**Второй подход (быстрый):**

1.  `var i1 int`: Выделяется память под целое число `i1` на стеке.
2.  `x1 := &X{ p: &i1, }`: Выделяется память под структуру `X` на стеке, если компилятор может определить, что время жизни `x1` ограничено текущей функцией и `x1` не "убегает" ([[Escape Analysis]]) в кучу. Инициализация поля `p` происходит одновременно с созданием структуры.

Ключевое различие заключается в том, где выделяется память под структуру `X`. В первом случае, поскольку структура `X` создаётся пустой (`&X{}`), а затем её полю присваивается значение, компилятор *не может* гарантировать, что структура не будет использоваться за пределами текущей функции (например, возвращена из функции или передана в горутину). Следовательно, он вынужден выделять память для `X` на куче.

Во втором случае, компилятор видит, что структура `X` инициализируется сразу с адресом локальной переменной `i1`. Это даёт компилятору больше информации, и он может применить оптимизацию, известную как "анализ убегания" (Escape Analysis). Если компилятор определяет, что `x1` не "убегает", он может выделить память для `X` на стеке. Выделение на стеке значительно быстрее, чем на куче, поскольку это просто сдвиг указателя стека.

## Измерение производительности

Тест производительности `BenchmarkAssignmentIndirect` измеряет время выполнения этих двух подходов. Результаты (0.2588 ns/op для второго подхода и 12.36 ns/op для первого) наглядно показывают, что выделение на стеке (второй подход) значительно быстрее.

## Альтернативные решения и их производительность

В данном конкретном случае альтернативных решений, которые были бы *значительно* более производительными, нет. Можно рассмотреть следующие варианты, но они не дадут существенного выигрыша, а некоторые могут даже ухудшить производительность:

1.  **Использовать пул объектов (sync.Pool):** Если структуры `X` создаются и уничтожаются очень часто, можно использовать `sync.Pool` для переиспользования объектов. Это уменьшит нагрузку на сборщик мусора ([[Garbage Collection]]). Однако, в данном тесте это, скорее всего, не даст выигрыша, так как структуры создаются в цикле и сразу же становятся недоступными. `sync.Pool` имеет смысл, когда объекты создаются редко, но живут долго.

    ```go
    package main_test

    import (
    	"sync"
    	"testing"
    )

    type X struct {
    	p *int
    }

    var xPool = sync.Pool{
    	New: func() interface{} {
    		return &X{}
    	},
    }

    func BenchmarkAssignmentIndirectWithPool(b *testing.B) {
    	for i := 0; i < b.N; i++ {
    		var i1 int
    		x1 := xPool.Get().(*X)
    		x1.p = &i1
    		_ = x1
    		xPool.Put(x1)

    	}
    }

    ```

    В этом примере, мы используем `sync.Pool` для хранения и повторного использования объектов `X`.
    `xPool.Get()` извлекает объект из пула, а `xPool.Put()` возвращает его обратно после использования.
    Однако в данном случае, это решение, скорее всего, не даст выигрыша, так как структуры создаются в цикле и сразу же становятся недоступными.

2.  **Избегать указателей вообще:** Если семантика позволяет, можно хранить в структуре не указатель на `int`, а само значение `int`. Это исключит необходимость выделения памяти под `int` отдельно. Однако, это изменит семантику: изменение значения в структуре не будет влиять на исходную переменную.

    ```go
    package main_test

    import "testing"

    func BenchmarkAssignmentDirect(b *testing.B) {
    	type X struct {
    		p int
    	}
    	for i := 0; i < b.N; i++ {
    		x1 := X{
    			p: 123, // some value
    		}
    		_ = x1
    	}
    }
    ```
     В этом примере структура `X` содержит не указатель, а само значение `int`.

3. **Передача по значению:** Если размер структуры `X` небольшой (как в данном случае), передача её по значению (а не по указателю) в функции может быть быстрее, так как это позволит избежать косвенного доступа через указатель. Однако, это также изменит семантику: изменения внутри функции не будут видны вне функции.

## Выводы

Наиболее эффективным способом инициализации структуры `X` в данном случае является одновременная инициализация структуры и её поля-указателя на локальную переменную. Это позволяет компилятору Go применить оптимизацию Escape Analysis и, при возможности, выделить память под структуру на стеке, что значительно быстрее, чем выделение на куче. Альтернативные решения, такие как использование `sync.Pool` или изменение структуры, либо не дадут существенного выигрыша в производительности, либо изменят семантику кода.

```old
[Go To Memory](https://habr.com/ru/companies/oleg-bunin/articles/676332/)

\`\`\`go
package main_test

import "testing"

func BenchmarkAssignmentIndirect(b *testing.B) {
	type X struct {
		p *int
	}
	for i := 0; i < b.N; i++ {
		// go test -bench=. >>> 0.2588 ns/op
		var i1 int
		x1 := &X{
			p: &i1,
		}
		_ = x1

		// go test -bench=. >>> 12.36 ns/op
		// var i2 int
		// x2 := &X{}
		// x2.p = &i2
	}
}
\`\`\`

```