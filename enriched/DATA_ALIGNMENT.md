#golang #memory #alignment #padding #benchmark #cache #optimization #performance #struct #slice

# Оптимизация использования кэша и выравнивание данных в Go

```table-of-contents
```

## Введение

Представленный код демонстрирует примеры структур `Foo1` и `Foo2`, а также бенчмарки `BenchmarkSum1` и `BenchmarkSum2`, измеряющие производительность суммирования поля `i` в срезах этих структур. Основная цель - показать, как выравнивание данных влияет на производительность. Однако, в текущем виде, пример не демонстрирует значительной разницы в производительности, потому что оптимизатор компилятора Go может переупорядочить поля структуры для минимизации заполнения, нивелируя разницу. Чтобы продемонстрировать выгоду от выравнивания, необходимо внести изменения, которые предотвратят автоматическую оптимизацию и заставят процессор работать с неоптимальным расположением данных в памяти.

## Проблема исходного примера

Компилятор Go, в целях оптимизации, может изменять порядок полей в структурах, чтобы уменьшить размер структуры за счет лучшего выравнивания. В данном случае, он, вероятно, переупорядочивает поля `Foo1` так, что она фактически становится эквивалентной `Foo2` по расположению в памяти. Поэтому оба бенчмарка показывают схожие результаты.

## Решение: предотвращение оптимизации компилятора

Чтобы увидеть разницу в производительности, вызванную разным выравниванием, нужно предотвратить оптимизацию компилятора. Это можно сделать несколькими способами. Рассмотрим два основных подхода:

### 1. Использование `unsafe.Pointer` и ручное вычисление смещений

Этот метод предполагает ручное создание массива байтов и доступ к полю `i` структуры `Foo1` через `unsafe.Pointer`, явно указывая смещение. Это не позволит компилятору переупорядочивать поля, так как мы напрямую работаем с байтами.

```go
package main

import (
	"testing"
	"unsafe"
)

type Foo1 struct {
	b1 byte
	i  int64
	b2 byte
}

func sum1(foos []byte, offset int) int64 {
	var s int64
	for j := 0; j < len(foos); j += int(unsafe.Sizeof(Foo1{})) {
		p := unsafe.Pointer(&foos[j])
		iPtr := (*int64)(unsafe.Pointer(uintptr(p) + uintptr(offset)))
		s += *iPtr
	}
	return s
}

type Foo2 struct {
	i  int64
	b1 byte
	b2 byte
}

func sum2(foos []Foo2) int64 {
	var s int64
	for i := 0; i < len(foos); i++ {
		s += foos[i].i
	}
	return s
}

var ln = 10_000_000

func BenchmarkSum1(b *testing.B) {
	foos := make([]byte, ln*int(unsafe.Sizeof(Foo1{}))) // Создаем сырой массив байтов.
	offset := int(unsafe.Offsetof(Foo1{}.i)) // Получаем смещение поля i.

	// Инициализируем "сырые" данные.
	for j := 0; j < len(foos); j += int(unsafe.Sizeof(Foo1{})) {
		p := unsafe.Pointer(&foos[j])
		iPtr := (*int64)(unsafe.Pointer(uintptr(p) + uintptr(offset)))
		*iPtr = int64(j / int(unsafe.Sizeof(Foo1{})))
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		sum1(foos, offset)
	}
}

func BenchmarkSum2(b *testing.B) {
	foos := make([]Foo2, ln)
	for i := 0; i < ln; i++ {
		foos[i] = Foo2{i: int64(i)}
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		sum2(foos)
	}
}

```

**Пояснение:**

1.  **`sum1` модифицирована:** Функция `sum1` теперь принимает срез байтов `foos` и смещение `offset` поля `i`.
2.  **Сырой массив байтов:** Вместо среза `Foo1` создается сырой массив байтов `[]byte`, размер которого равен количеству элементов, умноженному на размер структуры `Foo1`.
3.  **`unsafe.Offsetof`:**  Получаем смещение поля `i` в структуре `Foo1` с помощью `unsafe.Offsetof`.
4.  **Ручной доступ к данным:** Внутри цикла `sum1` мы используем `unsafe.Pointer` для получения указателя на текущий элемент массива байт. Затем, используя смещение, вычисляем адрес поля `i` и разыменовываем его.
5. **Инициализация:** Инициализация данных тоже происходит вручную, с учетом смещения.

**Плюсы:**

*   Полный контроль над расположением данных в памяти.
*   Гарантированное различие в производительности между `BenchmarkSum1` и `BenchmarkSum2`.

**Минусы:**

*   Использование `unsafe` пакета, что снижает безопасность кода и может привести к ошибкам, если не использовать его с осторожностью.
*   Сложность кода и его понимания.
*   Код становится менее переносимым, так как он зависит от конкретного размера и выравнивания типов данных на целевой архитектуре.

### 2. Использование массива структур с разным порядком полей

Второй подход - создать массив, содержащий структуры с разным порядком полей, но одинаковым содержимым.

```go
package main

import (
	"testing"
)

type Foo1 struct {
	b1 byte
	i  int64
	b2 byte
}

type Foo2 struct {
	i  int64
	b1 byte
	b2 byte
}

type FooMix struct {
    Variant uint8 // 0 for Foo1, 1 for Foo2
    Data [24]byte // Enough space for either Foo1 or Foo2
}

func sumMix(foos []FooMix) int64 {
	var s int64
	for i := 0; i < len(foos); i++ {
        if foos[i].Variant == 0 {
            s += (*Foo1)(unsafe.Pointer(&foos[i].Data)).i
        } else {
            s += (*Foo2)(unsafe.Pointer(&foos[i].Data)).i
        }
	}
	return s
}

func sum2(foos []Foo2) int64 {
	var s int64
	for i := 0; i < len(foos); i++ {
		s += foos[i].i
	}
	return s
}

var ln = 10_000_000

func BenchmarkSumMix(b *testing.B) {
    foos := make([]FooMix, ln)
    for i := 0; i < ln; i++ {
        if i%2 == 0 {
            foos[i] = FooMix{Variant: 0, Data: *(*[24]byte)(unsafe.Pointer(&Foo1{i: int64(i)}))}
        } else {
           foos[i] = FooMix{Variant: 1, Data: *(*[24]byte)(unsafe.Pointer(&Foo2{i: int64(i)}))}
        }
    }
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        sumMix(foos)
    }
}

func BenchmarkSum2(b *testing.B) {
	foos := make([]Foo2, ln)
	for i := 0; i < ln; i++ {
		foos[i] = Foo2{i: int64(i)}
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		sum2(foos)
	}
}

```

**Пояснение:**

1. **`FooMix`:** Вводится новая структура `FooMix`, которая может содержать данные как `Foo1`, так и `Foo2`. Поле `Variant` указывает, какой тип данных хранится в `Data`. `Data` - это массив байт, достаточно большой, чтобы вместить любую из структур.
2. **`sumMix`:** Функция `sumMix` итерирует по массиву `FooMix` и, в зависимости от значения `Variant`, приводит `Data` к соответствующему типу (`Foo1` или `Foo2`) и извлекает значение `i`.
3. **Инициализация:** В `BenchmarkSumMix` массив заполняется попеременно структурами `Foo1` and `Foo2`, упакованными в `FooMix`.
4. **BenchmarkSum2** остается прежним.

**Плюсы:**

*   Меньшее использование `unsafe` по сравнению с первым методом.
*  Наглядно демонстрируется разница в производительности.

**Минусы:**

*   Все равно требуется использование `unsafe`.
*   Увеличение сложности кода.
*   Неэффективное использование памяти из-за `FooMix`.

### 3. Увеличение размера массива и варьирование количества промахов кэша

Чтобы увидеть разницу в производительности, нужно создать условия при которых будет заметное количество промахов кэша ([[Cache Misses]]). Один из способов добиться этого - значительно увеличить размер массива, чтобы он не помещался в кэш целиком.

```go
package main

import (
	"testing"
)

type Foo1 struct {
	b1 byte
	i  int64
	b2 byte
}

func sum1(foos []Foo1) int64 {
	var s int64
	for i := 0; i < len(foos); i++ {
		s += foos[i].i
	}
	return s
}

type Foo2 struct {
	i  int64
	b1 byte
	b2 byte
}

func sum2(foos []Foo2) int64 {
	var s int64
	for i := 0; i < len(foos); i++ {
		s += foos[i].i
	}
	return s
}

// Значительно увеличиваем размер массива
var ln = 100_000_000 // 100 миллионов

func BenchmarkSum1(b *testing.B) {
	foos := make([]Foo1, ln)
	for i := 0; i < ln; i++ {
		foos[i] = Foo1{i: int64(i)}
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		sum1(foos)
	}
}

func BenchmarkSum2(b *testing.B) {
	foos := make([]Foo2, ln)
	for i := 0; i < ln; i++ {
		foos[i] = Foo2{i: int64(i)}
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		sum2(foos)
	}
}

```

**Пояснение:**

1.  **Увеличение `ln`:** Значительно увеличиваем размер массива `ln` до 100 миллионов или больше. Это гарантирует, что данные не поместятся в кэш процессора, и количество промахов кэша будет значительным.

**Плюсы:**

*   Простота реализации.
*   Не требует использования `unsafe`.

**Минусы:**

*   Не гарантирует *значительной* разницы в производительности, если оптимизатор компилятора все же сможет переупорядочить поля. Разница может быть, но не такая выраженная, как в первых двух методах.
*   Тест может выполняться дольше из-за большого размера массива.

## Выбор оптимального решения

Выбор метода зависит от целей и требований. Если нужна максимальная наглядность и полный контроль, то подойдет первый метод с `unsafe.Pointer`. Если нужно избежать чрезмерного использования `unsafe`, но при этом показать разницу, можно использовать второй метод с `FooMix`. Третий метод самый простой, но может не дать такой явной разницы в производительности.

В большинстве реальных задач, если вы не пишете низкоуровневый код, работающий с железом напрямую, лучше всего положиться на оптимизатор компилятора Go и использовать структуры, подобные `Foo2`, где поля расположены в порядке уменьшения размера. Компилятор сам позаботится о выравнивании, и код будет более читаемым и безопасным.

## Заключение

Выравнивание данных и оптимизация использования кэша - важные аспекты при разработке высокопроизводительных приложений. В Go, как правило, лучше позволить компилятору заниматься выравниванием, но в некоторых специфических случаях может потребоваться ручное управление расположением данных в памяти. Приведенные примеры показывают, как можно искусственно создать ситуацию, когда разница в производительности из-за выравнивания становится заметной, и как можно использовать `unsafe` для обхода оптимизаций компилятора. Однако, использовать `unsafe` следует с большой осторожностью, так как это может привести к трудноуловимым ошибкам и проблемам с безопасностью.

```old
У примера абсолютно одинаковые результаты замеров для обоих бенчмарков; как изменить, чтобы было наглядно видна выгода от выравнивания заполнением?

Поскольку каждая кэш-линия содержит в себе большее число переменных i, итерация по срезу Foo2 требует меньшего общего количества кэш-линий

\`\`\`go
package main

import (
	"testing"
)

type Foo1 struct {
	b1 byte
	i  int64
	b2 byte
}

func sum1(foos []Foo1) int64 {
	var s int64
	for i := 0; i < len(foos); i++ {
		s += foos[i].i
	}
	return s
}

type Foo2 struct {
	i  int64
	b1 byte
	b2 byte
}

func sum2(foos []Foo2) int64 {
	var s int64
	for i := 0; i < len(foos); i++ {
		s += foos[i].i
	return s
}

var ln = 10_000_000

func BenchmarkSum1(b *testing.B) {
	foos := make([]Foo1, ln)
	for i := 0; i < ln; i++ {
		foos[i] = Foo1{i: int64(i)}
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		sum1(foos)
	}
}

func BenchmarkSum2(b *testing.B) {
	foos := make([]Foo2, ln)
	for i := 0; i < ln; i++ {
		foos[i] = Foo2{i: int64(i)}
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		sum2(foos)
	}
}

func main() {
  println(unsafe.Sizeof(Foo1{})) // 24
  println(unsafe.Sizeof(Foo2{})) // 16
  //
	println("alignof(Foo1.i) =", unsafe.Alignof(Foo1{}.i), "offset =", unsafe.Offsetof(Foo1{}.i))
	println("alignof(Foo2.i) =", unsafe.Alignof(Foo2{}.i), "offset =", unsafe.Offsetof(Foo2{}.i))
}
\`\`\`

```