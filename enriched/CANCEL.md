#goroutines #concurrency #context #go #golang #programming #parallelism #synchronization #cancellation #signals

# Одновременный запуск горутин с прерыванием

```table-of-contents
```

## Задача

Требуется запустить две горутины параллельно. Если одна из горутин завершает свою работу, необходимо уведомить вторую горутину и прервать её выполнение.

## Решение с использованием `context.Context`

Для решения этой задачи наиболее подходящим инструментом является пакет `context` в Go. Этот пакет предоставляет механизм распространения сигналов отмены, крайних сроков и значений через границы API и между процессами.

### Шаг 1: Создание контекста с возможностью отмены

В начале функции `main` создается контекст `ctx` с функцией отмены `cancel`. Функция `context.WithCancel(context.Background())` возвращает производный контекст от `context.Background()`, который может быть отменен. Вызов функции `cancel` отменяет этот контекст и все производные от него контексты.

```go
ctx, cancel := context.WithCancel(context.Background())
```

### Шаг 2: Запуск первой горутины

Первая горутина запускается с использованием ключевого слова `go`. Внутри горутины выполняется некоторая работа (в данном примере - имитация работы с помощью `time.Sleep`). Ключевым моментом является использование `defer cancel()`. Оператор `defer` гарантирует, что функция `cancel` будет вызвана перед выходом из горутины, независимо от того, как завершится выполнение горутины (успешно или с ошибкой). Таким образом, при завершении работы первой горутины будет вызван `cancel()`, что приведет к отмене контекста `ctx`.

```go
go func() {
	defer cancel() // Сообщить второй горутине при завершении работы
	// Симуляция работы
	time.Sleep(2 * time.Second)
	fmt.Println("Первая горутина завершила работу")
}()
```

### Шаг 3: Запуск второй горутины

Вторая горутина также запускается с использованием `go`.  Ей передается контекст `ctx` в качестве аргумента. Внутри горутины используется бесконечный цикл `for` и оператор `select`.  Оператор `select` позволяет горутине ожидать нескольких операций над каналами.  В данном случае горутина ожидает двух событий:

1.  `<-ctx.Done()`:  Этот канал закрывается, когда контекст `ctx` отменяется.  Если канал закрыт, значит, первая горутина завершила работу, и вторая горутина должна прервать свое выполнение. В этом случае выводится сообщение об прерывании и горутина завершает работу с помощью `return`.

2.  `default`:  Если канал `ctx.Done()` еще не закрыт, выполняется блок `default`.  В этом блоке выполняется некоторая работа (в данном примере - имитация работы).

```go
go func(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			fmt.Println("Вторая горутина прервана")
			return
		default:
			// Симуляция работы
			fmt.Println("Вторая горутина работает")
			time.Sleep(1 * time.Second)
		}
	}
}(ctx)
```

### Шаг 4: Ожидание

В конце функции `main` добавляется `time.Sleep`, чтобы основная горутина не завершилась раньше времени, пока не завершатся дочерние горутины. Это нужно только для демонстрации, в реальном приложении это скорее всего не потребуется.

```go
time.Sleep(5 * time.Second)
```

### Полный код решения

```go
package main

import (
	"context"
	"fmt"
	"time"
)

func main() {
	ctx, cancel := context.WithCancel(context.Background())

	// Первая горутина
	go func() {
		defer cancel() // Сообщить второй горутине при завершении работы
		// Симуляция работы
		time.Sleep(2 * time.Second)
		fmt.Println("Первая горутина завершила работу")
	}()

	// Вторая горутина
	go func(ctx context.Context) {
		for {
			select {
			case <-ctx.Done():
				fmt.Println("Вторая горутина прервана")
				return
			default:
				// Симуляция работы
				fmt.Println("Вторая горутина работает")
				time.Sleep(1 * time.Second)
			}
		}
	}(ctx)

	// Ожидание завершения работы горутин
	time.Sleep(5 * time.Second)
}
```

### Преимущества использования `context.Context`

*   **Стандартный подход**: `context` является стандартным способом управления временем жизни горутин и передачи сигналов отмены в Go.
*   **Распространение отмены**: Контекст может быть передан через несколько уровней вызовов функций и горутин, обеспечивая централизованное управление отменой.
*   **Безопасность типов**: `context` позволяет передавать значения, связанные с запросом, безопасным для типов способом.
* **Интеграция**: Многие библиотеки Go (например, для работы с HTTP, базами данных) уже используют `context` для управления временем жизни запросов и операций.

### Альтернативные решения

Существуют и другие способы решения этой задачи, но они менее предпочтительны по сравнению с `context.Context`.

1.  **Использование каналов**: Можно создать отдельный канал для передачи сигнала отмены. Первая горутина при завершении работы отправит сообщение в этот канал, а вторая горутина будет ожидать сообщения из этого канала.

    *   **Недостатки**:  Этот подход менее гибкий, чем `context.Context`, так как не позволяет легко распространять сигнал отмены через несколько уровней вызовов функций и горутин. Также сложнее обрабатывать крайние сроки и передавать значения.

2.  **Использование `sync.WaitGroup` и атомарных переменных**: Можно использовать `sync.WaitGroup` для ожидания завершения горутин и атомарную переменную (например, `atomic.Bool`) для передачи сигнала отмены.

    *   **Недостатки**: Этот подход более сложен в реализации и менее читаем, чем использование `context.Context`.

## Подробное объяснение работы `context`

Пакет `context` в Go предоставляет механизм для передачи крайних сроков, сигналов отмены и других значений, относящихся к запросу, через границы API и между процессами. Основной тип в этом пакете - это `Context`.

`Context` - это интерфейс, который определяет четыре метода:

*   `Deadline() (deadline time.Time, ok bool)`: Возвращает время, когда работа, выполняемая от имени этого контекста, должна быть отменена. `ok` равно `false`, если крайний срок не установлен.
*   `Done() <-chan struct{}`: Возвращает канал, который закрывается, когда работа, выполняемая от имени этого контекста, должна быть отменена.
*   `Err() error`: Возвращает ошибку, объясняющую, почему был закрыт канал `Done`.
*   `Value(key interface{}) interface{}`: Возвращает значение, связанное с этим контекстом для данного ключа, или `nil`, если значение для данного ключа не найдено.

Функция `context.WithCancel(parent Context)` возвращает копию родительского контекста с новым каналом `Done`. Канал `Done` возвращенного контекста закрывается, когда вызывается возвращенная функция `cancel` или когда закрывается канал `Done` родительского контекста, в зависимости от того, что произойдет раньше.

[[context]]

```old
Одновременно запускаю две горутины. Если первая горутина закончила работу, нужно как-то сообщить второй горутине, чтобы она прервала свою работу.

\`\`\`go
package main

import (
	"context"
	"fmt"
	"time"
)

func main() {
	ctx, cancel := context.WithCancel(context.Background())

	// Первая горутина
	go func() {
		defer cancel() // Сообщить второй горутине при завершении работы
		// Симуляция работы
		time.Sleep(2 * time.Second)
		fmt.Println("Первая горутина завершила работу")
	}()

	// Вторая горутина
	go func(ctx context.Context) {
		for {
			select {
			case <-ctx.Done():
				fmt.Println("Вторая горутина прервана")
				return
			default:
				// Симуляция работы
				fmt.Println("Вторая горутина работает")
				time.Sleep(1 * time.Second)
			}
		}
	}(ctx)

	// Ожидание завершения работы горутин
	time.Sleep(5 * time.Second)
}
\`\`\`

```