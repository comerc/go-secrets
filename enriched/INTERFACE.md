#go #types #methods #pointers #interfaces #Stringer #compiletime #runtime #typeassertion

# Методы для значений и указателей в Go

```table-of-contents
```

Рассмотрим представленный код на языке Go, который демонстрирует различие в доступности методов для значений и указателей.

## Анализ кода

В коде определены два типа: `Celsius` и `Fahrenheit`, оба являются псевдонимами `float64`. Для каждого из них определен метод `String() string`, который позволяет им соответствовать интерфейсу `fmt.Stringer`.

```go
package main

import "fmt"

type Celsius float64

func (Celsius) String() string {
	return "C"
}

type Fahrenheit float64

func (*Fahrenheit) String() string {
	return "F"
}

func main() {
	var _ fmt.Stringer = (*Celsius)(nil)
	var _ fmt.Stringer = (*Fahrenheit)(nil) // компиляция проходит

	var _ fmt.Stringer = Celsius(20.0)
	// var _ fmt.Stringer = Fahrenheit(20.0) // компиляция не проходит
}
```

Ключевое различие заключается в том, как определены методы `String()`:

1.  Для `Celsius` метод определен для *значения* типа `Celsius`: `func (Celsius) String() string`.
2.  Для `Fahrenheit` метод определен для *указателя* на тип `Fahrenheit`: `func (*Fahrenheit) String() string`.

В функции `main` происходят следующие проверки соответствия интерфейсу `fmt.Stringer`:

1.  `var _ fmt.Stringer = (*Celsius)(nil)`: Проверка успешна. Указатель на `Celsius` (`*Celsius`) автоматически получает доступ к методам, определенным для значения `Celsius`.
2.  `var _ fmt.Stringer = (*Fahrenheit)(nil)`: Проверка успешна. Указатель на `Fahrenheit` (`*Fahrenheit`) имеет определенный для него метод `String()`.
3.  `var _ fmt.Stringer = Celsius(20.0)`: Проверка успешна. Значение `Celsius` имеет определенный для него метод `String()`.
4.  `var _ fmt.Stringer = Fahrenheit(20.0)`:  **Ошибка компиляции**. Значение `Fahrenheit` *не* имеет доступа к методу `String()`, который определен только для *указателя* `*Fahrenheit`.

## Подробное объяснение

В Go существует важное правило, касающееся методов и указателей:

*   Методы, определенные для типа `T`, доступны как для значений `T`, так и для указателей `*T`. Это происходит потому, что Go автоматически разыменовывает указатель при вызове метода.
*   Методы, определенные для указателя `*T`, доступны *только* для указателей `*T`. Значения `T` не имеют доступа к этим методам.

Это связано с тем, как Go работает с памятью и возможностью изменения значений. Методы, определенные для указателей, могут изменять значение, на которое указывает указатель. Если бы эти методы были доступны для значений, это могло бы привести к неожиданному поведению, так как изменения значения внутри метода не отразились бы на исходной переменной.

**Пример с изменением значения:**

```go
package main

import "fmt"

type MyInt int

func (m *MyInt) Increment() {
	*m++
}

func (m MyInt) Print() {
    fmt.Println(m)
}

func main() {
	var x MyInt = 5
	x.Print()      // Вывод: 5
	x.Increment() // Ошибка компиляции: cannot call pointer method on MyInt
    (&x).Increment()
    x.Print() // Вывод: 6

	p := &x
    p.Print()
	p.Increment()
    p.Print() // Вывод: 7
	fmt.Println(x) // Вывод: 7
}
```

В этом примере метод `Increment()` определен для указателя `*MyInt`. Он изменяет значение, на которое указывает указатель. Попытка вызвать `Increment()` напрямую для значения `x` приводит к ошибке компиляции. Однако, если мы возьмем адрес `x` (получим указатель `&x`), то сможем вызвать метод `Increment()`, и значение `x` изменится. Метод `Print()` определен для значения `MyInt`. Он доступен как для значения `x` так и для указателя `p`.

## Причины такого поведения

Такое поведение обусловлено несколькими причинами:

1.  **Безопасность типов:** Ограничение доступа к методам указателей для значений помогает предотвратить случайное изменение данных.
2.  **Ясность кода:** Четко разделяется, какие методы могут изменять данные, а какие нет. Методы, определенные для указателей, явно указывают на возможность изменения.
3.  **Производительность:** В некоторых случаях Go может оптимизировать вызовы методов, зная, что значение не будет изменено.

## Альтернативные решения и их сравнение

В данном случае, если необходимо, чтобы и значение, и указатель `Fahrenheit` соответствовали интерфейсу `fmt.Stringer`, есть два основных варианта:

1.  **Определить метод `String()` для значения `Fahrenheit`:**

    ```go
    func (Fahrenheit) String() string {
        return "F"
    }
    ```

    *   **Плюсы:** Простота, код становится более единообразным.
    *   **Минусы:** Если метод должен изменять значение, то это невозможно сделать напрямую, нужно использовать указатели.

2.  **Использовать указатели везде, где требуется `fmt.Stringer` для `Fahrenheit`:**

    ```go
    var f Fahrenheit = 20.0
    var _ fmt.Stringer = &f // Используем указатель
    ```

    *   **Плюсы:** Сохраняется возможность изменения значения внутри метода.
    *   **Минусы:** Менее удобно, требует явного использования указателей.

Выбор между этими вариантами зависит от конкретной задачи. Если метод `String()` не должен изменять значение `Fahrenheit` (как в данном случае), то предпочтительнее определить его для значения.  Это сделает код более читаемым и простым. Если же изменение необходимо, то придется использовать указатели.

##  [[Type Assertion]]

В некоторых ситуациях может потребоваться проверить, реализует ли конкретное значение интерфейс, и если да, то получить доступ к методам этого интерфейса, even если изначально переменная имеет другой тип. Для этого используется [[Type Assertion]].

Применительно к нашему примеру, если бы у нас была переменная типа `interface{}`, содержащая значение `Fahrenheit`, мы могли бы использовать утверждение типа, чтобы проверить, реализует ли она `fmt.Stringer`, и вызвать метод `String()`:

```go
var i interface{} = Fahrenheit(20.0)

if s, ok := i.(fmt.Stringer); ok {
	fmt.Println(s.String()) // Ошибка, так как String() определен для *Fahrenheit
}
if s, ok := i.(*Fahrenheit); ok {
	fmt.Println(s.String()) // Вывод: F, так как String() определен для *Fahrenheit
}
```
В первом `if` мы делаем `type assertion` к интерфейсу `fmt.Stringer` и это не сработает, поскольку у нас нет метода `String()` определенного для `Fahrenheit`, а есть только для`*Fahrenheit`. Во втором `if` мы делаем `type assertion` к типу `*Fahrenheit` и это срабатывает.
## Заключение
Правильное понимание разницы между методами для значений и указателей в Go является критически важным для написания корректного и эффективного кода. Это помогает избежать ошибок, связанных с неожиданным изменением данных, и делает код более ясным и предсказуемым.

```old
\`\`\`go
package main

import "fmt"

type Celsius float64

func (Celsius) String() string {
	return "C"
}

type Fahrenheit float64

func (*Fahrenheit) String() string {
	return "F"
}

func main() {
	var _ fmt.Stringer = (*Celsius)(nil)
	var _ fmt.Stringer = (*Fahrenheit)(nil) // компиляция проходит

	var _ fmt.Stringer = Celsius(20.0)
	// var _ fmt.Stringer = Fahrenheit(20.0) // компиляция не проходит
}
\`\`\`

Методы, определенные для типа T, также доступны для указателей этого типа (*T). Однако обратное не верно: методы, определенные для *T, не доступны для T.

```