#falseSharing #go #concurrency #padding #channel #cacheLine #optimization #benchmark #memory #goroutine

# Ложное совместное использование и его предотвращение в Go

```table-of-contents
```

## Введение в проблему ложного совместного использования

Ложное совместное использование (False Sharing) — это ситуация, возникающая в многопроцессорных системах, когда несколько ядер (или потоков) обращаются к разным данным, которые, тем не менее, находятся в одной и той же строке кэша. Это приводит к нежелательным накладным расходам, связанным с необходимостью синхронизации кэша между ядрами, даже если фактически данные не являются общими.

[[Кэш-линия]] — это наименьшая единица данных, которой оперирует кэш процессора. Обычно размер кэш-линии составляет 64 байта.

Рассмотрим пример кода на Go, который демонстрирует проблему ложного совместного использования.

## Пример кода с ложным совместным использованием

```go
package main

import (
	"sync"
	"testing"
)

type Input struct {
	a int64
	b int64
}

type Result struct {
	sumA int64
	// _    [56]byte // улучшение до 20%
	sumB int64
}

func count(inputs []Input) Result {
	wg := sync.WaitGroup{}
	wg.Add(2)
	result := Result{}
	go func() {
		for i := 0; i < len(inputs); i++ {
			result.sumA += inputs[i].a
		}
		wg.Done()
	}()
	go func() {
		for i := 0; i < len(inputs); i++ {
			result.sumB += inputs[i].b
		}
		wg.Done()
	}()
	wg.Wait()
	return result
}

const ln = 10_000_000

func BenchmarkCount(b *testing.B) {
	inputs := make([]Input, ln)
	for i := 0; i < ln; i++ {
		inputs[i] = Input{a: int64(i), b: int64(i)}
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		count(inputs)
	}
}
```

В этом коде две горутины параллельно вычисляют суммы элементов `a` и `b` в массиве `inputs`. Результаты записываются в структуру `Result`, где поля `sumA` и `sumB` расположены рядом в памяти.

## Проблема

Поля `sumA` и `sumB` структуры `Result` имеют тип `int64` (8 байт). Если размер кэш-линии 64 байта, то `sumA` и `sumB`, скорее всего, попадут в одну и ту же кэш-линию.

Когда первая горутина записывает данные в `sumA`, она модифицирует кэш-линию. Когда вторая горутина записывает данные в `sumB`, ей нужно получить обновленную кэш-линию, даже если она работает с другим полем. Это приводит к "перебрасыванию" кэш-линии между ядрами, что снижает производительность.

## Решения проблемы ложного совместного использования

Существует два основных способа предотвращения ложного совместного использования:

1.  **Заполнение (Padding)**: Добавление неиспользуемых байтов (заполнителя) между полями структуры, чтобы гарантировать, что они окажутся в разных кэш-линиях.
2.  **Коммуникация через каналы**: Использование каналов Go для передачи данных между горутинами вместо прямой записи в общую память.

## Решение 1: Заполнение (Padding)

В приведенном выше коде закомментирована строка `// _    [56]byte // улучшение до 20%`. Если ее раскомментировать, то между полями `sumA` и `sumB` добавится 56 байт заполнителя. В сумме с 8 байтами `sumA` это займет ровно одну кэш-линию (64 байта). Таким образом, `sumB` гарантированно окажется в следующей кэш-линии, и ложного совместного использования не произойдет.

**Преимущества:**

*   Простота реализации.
*   Не требует значительных изменений в логике программы.

**Недостатки:**

*   Увеличивает потребление памяти.
*   Зависит от размера кэш-линии (который может отличаться на разных платформах).

## Решение 2: Коммуникация через каналы

Вместо того, чтобы напрямую записывать результаты в общую структуру `Result`, можно использовать каналы для передачи промежуточных результатов из каждой горутины в основную горутину, которая будет агрегировать результаты.

```go
package main

import (
	"testing"
)

type Input struct {
	a int64
	b int64
}

type PartialResult struct {
	sumA int64
	sumB int64
}

func countWithChannels(inputs []Input) Result {
	resultsChan := make(chan PartialResult)
	numGoroutines := 2

	go func() {
		partialResultA := PartialResult{}
		for i := 0; i < len(inputs); i++ {
			partialResultA.sumA += inputs[i].a
		}
		resultsChan <- partialResultA
	}()

	go func() {
		partialResultB := PartialResult{}
		for i := 0; i < len(inputs); i++ {
			partialResultB.sumB += inputs[i].b
		}
		resultsChan <- partialResultB
	}()

	finalResult := Result{}
	for i := 0; i < numGoroutines; i++ {
		partialResult := <-resultsChan
		finalResult.sumA += partialResult.sumA
		finalResult.sumB += partialResult.sumB
	}
	close(resultsChan)

	return finalResult
}

const ln = 10_000_000

func BenchmarkCountWithChannels(b *testing.B) {
	inputs := make([]Input, ln)
	for i := 0; i < ln; i++ {
		inputs[i] = Input{a: int64(i), b: int64(i)}
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		countWithChannels(inputs)
	}
}
```

В этом примере каждая горутина вычисляет свой частичный результат (`partialResultA` и `partialResultB`) и отправляет его в канал `resultsChan`. Основная горутина получает эти частичные результаты из канала и суммирует их в итоговый результат `finalResult`.

**Преимущества:**

*   Более идиоматичный подход для Go, использующий механизм каналов.
*   Не зависит от размера кэш-линии.
*   Устраняет необходимость в явной синхронизации (мьютексы, атомарные операции), так как каналы обеспечивают безопасную коммуникацию между горутинами.

**Недостатки:**

*   Может быть немного сложнее в реализации, чем заполнение.
*   В некоторых случаях может быть менее производительным, чем модификация с padding, из-за накладных расходов на работу с каналами (зависит от конкретной ситуации и реализации каналов в Go).

## Сравнение производительности

Бенчмарки показывают, что заполнение может дать значительный прирост производительности (до 20% в данном примере), в то время как решение на основе каналов, как правило, имеет меньшую производительность по сравнению с оригинальным кодом из-за накладных расходов на коммуникацию. Однако, каналы обеспечивают более надежную и безопасную синхронизацию, что может быть важнее производительности в некоторых случаях.

## Выбор оптимального решения

Выбор между заполнением и каналами зависит от конкретной задачи и требований к производительности и надежности.

*   Если важна максимальная производительность и известно, что размер кэш-линии не изменится, то заполнение может быть предпочтительным вариантом.
*   Если важна безопасность и переносимость кода, а небольшое снижение производительности допустимо, то каналы могут быть лучшим выбором.

В общем случае, рекомендуется начинать с решения на основе каналов, так как оно более идиоматично для Go и обеспечивает лучшую безопасность. Если производительность оказывается недостаточной, можно рассмотреть возможность использования заполнения, тщательно протестировав и измерив производительность обоих вариантов.

```old
Ложное совместное использование происходит, когда какая-то кэш-линия совместно используется двумя ядрами и при этом хотя бы одна горутина что-то записывает в память. Можно предотвратить его либо с помощью заполнения (padding), либо с помощью коммуницирования через каналы.

\`\`\`go
package main

import (
	"sync"
	"testing"
)

type Input struct {
	a int64
	b int64
}

type Result struct {
	sumA int64
	// _    [56]byte // улучшение до 20%
	sumB int64
}

func count(inputs []Input) Result {
	wg := sync.WaitGroup{}
	wg.Add(2)
	result := Result{}
	go func() {
		for i := 0; i < len(inputs); i++ {
			result.sumA += inputs[i].a
		}
		wg.Done()
	}()
	go func() {
		for i := 0; i < len(inputs); i++ {
			result.sumB += inputs[i].b
		}
		wg.Done()
	}()
	wg.Wait()
	return result
}

const ln = 10_000_000

func BenchmarkCount(b *testing.B) {
	inputs := make([]Input, ln)
	for i := 0; i < ln; i++ {
		inputs[i] = Input{a: int64(i), b: int64(i)}
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		count(inputs)
	}
}
\`\`\`

```