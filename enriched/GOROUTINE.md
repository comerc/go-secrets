#goroutines #concurrency #multithreading #programming #go #threads #processes #lightweight_threads #operating_systems #parallelism

# Горутины, потоки и процессы: Ключевые различия и особенности

```table-of-contents
```

## Введение в горутины, потоки и процессы

Прежде чем погрузиться в детали различий, важно понять, что представляют собой горутины, потоки (threads) и процессы. Все три концепции связаны с параллельным и конкурентным выполнением задач в компьютерных системах, но реализуются и управляются они по-разному.

## Процессы

**Процесс** — это экземпляр выполняющейся программы. Каждый процесс имеет собственное, изолированное адресное пространство памяти, что означает, что процессы не могут напрямую обращаться к памяти друг друга. Это обеспечивает высокую степень изоляции, но усложняет межпроцессное взаимодействие (IPC, Inter-Process Communication). Для обмена данными между процессами используются специальные механизмы, такие как каналы (pipes), сокеты, очереди сообщений и разделяемая память (shared memory), которые требуют дополнительных системных вызовов и накладных расходов. Создание нового процесса — относительно "тяжелая" операция, требующая от операционной системы выделения значительных ресурсов.

![Процесс](https://i.stack.imgur.com/KiLoC.png)

## Потоки (Threads)

**Поток** — это единица выполнения внутри процесса. В отличие от процессов, потоки одного процесса разделяют общее адресное пространство памяти. Это упрощает обмен данными между потоками, но требует тщательной синхронизации доступа к общим ресурсам (с использованием мьютексов, семафоров и т.д.) для предотвращения состояний гонки (race conditions) и других проблем параллелизма. Создание потока — менее ресурсоемкая операция, чем создание процесса, но все же требует участия операционной системы.

![Потоки](https://www.guru99.com/images/2/112119_0539_Multithread1.png)

## Горутины

**Горутина** — это легковесный поток выполнения, управляемый не операционной системой, а средой выполнения языка программирования (в случае Go — рантаймом Go). Горутины мультиплексируются на небольшое количество потоков ОС, что позволяет создавать тысячи и даже миллионы горутин без значительных накладных расходов. Горутины используют кооперативную многозадачность: переключение между горутинами происходит в определенных точках (например, при вызове функций ввода-вывода, обращении к каналам или явном вызове `runtime.Gosched()`), а не по прерыванию планировщика ОС. Это упрощает управление параллелизмом и снижает накладные расходы на переключение контекста.

![Горутины](https://res.cloudinary.com/practicaldev/image/fetch/s--ZqMRCu5f--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/v41m5w63k657d7955f4a.png)

## Ключевые различия

1.  **Уровень управления:** Процессы и потоки управляются операционной системой, в то время как горутины управляются средой выполнения языка программирования.
2.  **Адресное пространство:** Процессы имеют изолированные адресные пространства, потоки разделяют общее адресное пространство, а горутины также работают в общем адресном пространстве (в рамках одного процесса).
3.  **Накладные расходы:** Создание процесса — самая "тяжелая" операция, создание потока — легче, создание горутины — самая "легкая" операция.
4.  **Межпроцессное/межпотоковое/межгорутинное взаимодействие:** Процессы используют IPC, потоки обмениваются данными через общую память (требуется синхронизация), горутины используют каналы (channels) для безопасного обмена данными.
5. **[[Планирование]]**: Процессы и нити планируются операционной системой. Горутины планируются средой выполнения Go. Планировщик среды выполнения Go мультиплексирует горутины поверх нескольких потоков операционной системы.

## Подробное сравнение

| Характеристика        | Процесс                                    | Поток (Thread)                               | Горутина                                                                                                  |
| :-------------------- | :------------------------------------------ | :------------------------------------------- | :-------------------------------------------------------------------------------------------------------- |
| Уровень управления    | Операционная система                        | Операционная система                         | Среда выполнения языка программирования (например, Go runtime)                                          |
| Адресное пространство | Изолированное                               | Общее (в рамках одного процесса)             | Общее (в рамках одного процесса)                                                                              |
| Накладные расходы    | Высокие                                     | Средние                                      | Низкие                                                                                                    |
| Взаимодействие       | Межпроцессное взаимодействие (IPC)         | Общая память (требуется синхронизация)      | Каналы (channels)                                                                                         |
| Масштабируемость     | Ограничена ресурсами ОС                     | Ограничена, но лучше, чем у процессов        | Очень высокая (тысячи и миллионы горутин)                                                                  |
| Пример (Go)           | Не применимо (Go не предоставляет примитивов для прямого управления процессами) | `import "sync"` и использование мьютексов и т.д. | `go func() { ... }` и использование каналов (`chan`)                                                 |

## Преимущества горутин

*   **Низкие накладные расходы:** Создание и уничтожение горутин значительно дешевле, чем создание и уничтожение потоков или процессов.
*   **Высокая масштабируемость:** Можно создавать огромное количество горутин, не перегружая систему.
*   **Упрощенное взаимодействие:** Каналы обеспечивают безопасный и простой способ обмена данными между горутинами, избавляя от необходимости вручную управлять блокировками и синхронизацией.
*   **Эффективное использование ресурсов:** Горутины мультиплексируются на небольшое количество потоков ОС, что позволяет более эффективно использовать ресурсы процессора.

## Пример использования горутин в Go

```go
package main

import (
	"fmt"
	"time"
)

func printNumbers(prefix string) {
	for i := 1; i <= 5; i++ {
		fmt.Printf("%s: %d\n", prefix, i)
		time.Sleep(100 * time.Millisecond) // Имитация работы
	}
}

func main() {
	go printNumbers("Горутина 1") // Запускаем функцию в отдельной горутине
	go printNumbers("Горутина 2") // Запускаем еще одну горутину

	time.Sleep(1 * time.Second) // Ждем, чтобы горутины успели завершиться (в реальном коде нужно использовать sync.WaitGroup или каналы)

	fmt.Println("Готово!")
}
```

В этом примере две функции `printNumbers` запускаются в отдельных горутинах. Они выполняются параллельно (или псевдопараллельно, если у вас одноядерный процессор), выводя числа с небольшими задержками.  `time.Sleep(1 * time.Second)` в `main` дает горутинам время для выполнения. В реальных приложениях вместо `time.Sleep` для ожидания завершения горутин следует использовать `sync.WaitGroup` или каналы.

## Заключение

Горутины, потоки и процессы — это разные подходы к организации параллельного и конкурентного выполнения кода. Горутины, благодаря своей легковесности и эффективному управлению средой выполнения языка, предоставляют удобный и масштабируемый способ решения задач, требующих параллелизма.  Понимание различий между этими концепциями помогает разработчикам выбирать наиболее подходящие инструменты для конкретных задач.

```old
## Что такое горутина и чем она отличается от тредов и процессов?

Горутина - это так называемый "легковесный поток", который реализован на программном уровне, в отличии от потоков и процессов операционной системы. Они дают нам слой абстракции для буферного накопления и распределения выполнения горутин между потоками в процессах операцинной системы. Что может быть гораздо эффективнее в мире многоядерных процессоров. Создание горутин несёт меньше накладных расходов, чем создание потоков. Множество горутин могут выполняться на одном потоке. Горутины общаются между собой через каналы.

---

Системные потоки и процессы - это две ключевые концепции, используемые в операционных системах для выполнения задач. Вот основные различия между ними:

**Процесс**:
- Процесс - это экземпляр программы, который выполняется.
- Каждый процесс имеет свое собственное адресное пространство и не делится его с другими процессами.
- Процессы требуют IPC (межпроцессное взаимодействие) для общения друг с другом.
- Каждый раз, когда мы создаем процесс, нам нужно сделать отдельный системный вызов для каждого процесса к ОС.

**Поток (Thread)**:
- Поток - это базовая единица использования ЦПУ, состоящая из счетчика программ, стека и набора регистров.
- Потоки выполнения образуются в результате разветвления компьютерной программы на две или более одновременно выполняющихся задач.
- Реализация потоков и процессов отличается от одной операционной системы к другой, но в большинстве случаев поток содержится внутри процесса.
- Несколько потоков могут существовать в рамках одного и того же процесса и делить ресурсы, такие как память, в то время как разные процессы не делят эти ресурсы.
- Потоки - это по сути процессы, которые работают в одном и том же контексте памяти.

Важно отметить, что потоки и процессы связаны, но в то же время являются ортогональными понятиями. Поток - это то, что фактически выполняет ЦПУ; это связано с планированием доступа к общим ресурсам (например, ЦПУ). Процесс - это выделенная память для инструкций и данных (процессу требуется память для кода и данных).

```