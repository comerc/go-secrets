#golang #unsafe #slices #optimization #benchmark #generics #memory #pointer #performance #comparison

# Сравнение производительности функций для работы со срезами в Go

```table-of-contents
```

## Введение

В Go существует несколько способов сравнения срезов (slices). В данном документе рассматривается производительность различных подходов, включая использование пакета `unsafe` и стандартной функции `slices.Equal`.

## Исходный код и проблема

Первоначальный код использует пакет `unsafe` для получения указателя на базовый массив среза и сравнения этих указателей.

```go
package main

import (
	"unsafe"
)

func getInternalArray[T unsafe.Pointer](nums ...int) T {
	return *(*T)(unsafe.Pointer(&nums[0]))
}

func main() {
	a := []int{1, 2, 3}
	b := []int{1, 2, 3}
	c := []int{3, 2, 1}
	println(getInternalArray(a...) == getInternalArray(b...)) // true
	println(getInternalArray(b...) == getInternalArray(c...)) // false
}
```

Этот код работает корректно в том смысле, что сравнивает указатели, но он имеет серьезные проблемы с производительностью, как показано в следующем разделе. Проблема в том, что передача `nums...` в функцию приводит к аллокации памяти под новый слайс, который содержит копию данных исходного среза. Это приводит к значительным накладным расходам при работе с большими срезами. Кроме того, тип `T` ограничен типом `unsafe.Pointer`, что не позволяет выполнять типобезопасное сравнение.

## Бенчмаркинг: начальный вариант

Бенчмарк показывает, что исходный код значительно медленнее, чем стандартная функция `slices.Equal`:

```go
package main

import (
	"slices"
	"testing"
	"unsafe"
)

func getInternalArray[T any](nums ...int) T {
	return *(*T)(unsafe.Pointer(&nums[0]))
}

var (
	a, c []int
)

func init() {
	a = make([]int, 10_000_000)
	c = make([]int, 10_000_000)
	for i := 0; i < 10_000_000; i++ {
		a[i] = i
		c[i] = i
	}
}

func BenchmarkOne(b *testing.B) {
	for i := 0; i < b.N; i++ {
		_ = getInternalArray[[10_000_000]int](a...) == getInternalArray[[10000000]int](c...)
	}
}

func BenchmarkTwo(b *testing.B) {
	for i := 0; i < b.N; i++ {
		slices.Equal(a, c)
	}
}
```

Результаты:

```
cpu: Intel(R) Core(TM) i5-10400 CPU @ 2.90GHz
BenchmarkOne-12    	      13	  86404167 ns/op	160006320 B/op	       2 allocs/op
BenchmarkTwo-12    	     120	   9667527 ns/op	       0 B/op	       0 allocs/op
```

`BenchmarkOne` (использование `getInternalArray`) показывает значительно худшие результаты по сравнению с `BenchmarkTwo` (использование `slices.Equal`).  `getInternalArray` требует значительно больше времени на операцию (86,404,167 нс против 9,667,527 нс) и выполняет две аллокации памяти на операцию, в то время как `slices.Equal` не требует аллокаций.

## Оптимизированный код

Код можно оптимизировать, избегая создания нового среза при передаче аргументов и используя явное указание типа для приведения указателя.

```go
package main

import (
	"slices"
	"testing"
	"unsafe"
)

func EqualSlices[T comparable](s1, s2 []int) bool {
	return *(*T)(unsafe.Pointer(&s1[0])) == *(*T)(unsafe.Pointer(&s2[0]))
}

var (
	a, c []int
)

func init() {
	a = make([]int, 10_000_000)
	c = make([]int, 10_000_000)
	for i := 0; i < 10_000_000; i++ {
		a[i] = i
		c[i] = i
	}
}

func BenchmarkOne(b *testing.B) {
	for i := 0; i < b.N; i++ {
		EqualSlices[[10_000_000]int](a, c)
	}
}

func BenchmarkTwo(b *testing.B) {
	for i := 0; i < b.N; i++ {
		slices.Equal(a, c)
	}
}
```
В этой версии `EqualSlices` принимает два среза `s1` и `s2` напрямую, а не переменное число аргументов.  Это устраняет необходимость в создании копии среза.  Затем с помощью `unsafe.Pointer` получается указатель на первый элемент каждого среза, и эти указатели приводятся к типу `T`, который задается как параметр-тип.  Затем выполняется сравнение значений, на которые указывают эти указатели. Важно, что тип `T` должен быть `comparable`, т.е. поддерживать операцию сравнения `==`.

## Бенчмаркин: оптимизированная версия

Новые результаты бенчмаркинга показывают значительное улучшение:

```
cpu: Intel(R) Core(TM) i5-10400 CPU @ 2.90GHz
BenchmarkOne-12    	     157	   7760157 ns/op	       0 B/op	       0 allocs/op
BenchmarkTwo-12    	     124	  10045822 ns/op	       0 B/op	       0 allocs/op
```

`BenchmarkOne` (оптимизированная версия `EqualSlices`) теперь выполняется значительно быстрее (7,760,157 нс/op) и не выполняет аллокаций памяти. Это быстрее, чем `slices.Equal` (10,045,822 нс/op).

## Подробное объяснение оптимизации

1.  **Устранение вариативных аргументов (`...`)**:  Исходная функция `getInternalArray` использовала вариативные аргументы (`nums ...int`).  При вызове функции с `...` Go создает *новый* срез, содержащий копии переданных элементов.  Это приводит к ненужным аллокациям памяти и копированию данных, особенно при работе с большими срезами. Оптимизированная функция `EqualSlices` принимает два среза напрямую (`s1`, `s2`), избегая этого накладного расхода.

2.  **Прямой доступ к первому элементу**: Вместо итерации по срезу или использования других методов доступа к элементам, оптимизированный код напрямую обращается к первому элементу среза с помощью индекса `0` (`s1[0]`, `s2[0]`).  Это позволяет получить адрес первого элемента (и, следовательно, адрес начала базового массива) без дополнительных операций.

3.  **Использование `unsafe.Pointer`**: Пакет `unsafe` в Go позволяет работать с памятью напрямую, обходя систему типов Go. `unsafe.Pointer` представляет собой "сырой" указатель, который может быть преобразован в указатель любого типа. В данном случае, `unsafe.Pointer(&s1[0])` получает указатель на первый элемент среза `s1`, а затем этот указатель преобразуется в тип `*T` с помощью `*(*T)(...)`.  Это позволяет сравнивать указатели на базовые массивы двух срезов.

4.  **Параметризация типа `T`**: Использование дженериков (`[T comparable]`) позволяет функции `EqualSlices` работать с различными типами данных, при условии, что эти типы поддерживают операцию сравнения (`comparable`).  В данном случае, мы явно указываем тип `[10_000_000]int` при вызове функции, сообщая компилятору, что мы сравниваем указатели на массивы из 10 миллионов целых чисел. Это важно для корректного приведения типа `unsafe.Pointer`.

5. **Сравнение указателей, а не содержимого:** Важно понимать, что в оптимизированной версии сравниваются *указатели* на базовые массивы срезов, а не *содержимое* этих массивов. Два среза будут считаться равными только в том случае, если они указывают на один и тот же базовый массив в памяти. Если два среза имеют одинаковое содержимое, но расположены в разных областях памяти, `EqualSlices` вернет `false`. `slices.Equal` же сравнивает содержимое.

## Сравнение решений

| Решение                                | Преимущества                                                                                                                                                                                                                                                                               | Недостатки                                                                                                                                                                                                                       |
| :-------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `getInternalArray` (исходный)          | Простота реализации.                                                                                                                                                                                                                                                              | Очень низкая производительность из-за аллокаций памяти и копирования данных. Не типобезопасный код.                                                                                                                                   |
| `slices.Equal` (стандартная библиотека) | Высокая производительность. Типобезопасность. Простота использования. Надежность (протестировано и поддерживается разработчиками Go). Сравнение содержимого массивов.                                                                                                                     | Может быть немного медленнее, чем оптимизированный `unsafe` код в *некоторых* специфических случаях (когда требуется сравнение именно указателей, а не содержимого), но разница как правило не столь значительна.            |
| `EqualSlices` (оптимизированный)       | Максимальная производительность в сценарии сравнения указателей на базовые массивы. Отсутствие аллокаций памяти.                                                                                                                                                                         | Использует пакет `unsafe`, что может привести к проблемам с безопасностью памяти, если использовать некорректно. Сравнивает *указатели*, а не содержимое. Менее читаемый и более сложный для понимания код. Менее переносимый. |

## Вывод

Оптимизированный код, использующий `unsafe.Pointer`, демонстрирует более высокую производительность по сравнению со стандартной функцией `slices.Equal` в специфическом случае, когда необходимо сравнить *указатели* на базовые массивы срезов, а не их содержимое. Однако, использование пакета `unsafe` сопряжено с рисками и требует особой осторожности. В большинстве случаев, когда необходимо сравнить *содержимое* срезов, рекомендуется использовать стандартную функцию `slices.Equal`, так как она обеспечивает типобезопасность, надежность и достаточную производительность. Применение `unsafe` оправдано только в крайне редких случаях, когда требуется максимальная производительность и точно известно, что сравнение указателей является корректным и безопасным.

```old
getInternalArray:

\`\`\`go
package main

import (
	"unsafe"
)

func getInternalArray[T unsafe.Pointer](nums ...int) T {
	return *(*T)(unsafe.Pointer(&nums[0]))
}

func main() {
	a := []int{1, 2, 3}
	b := []int{1, 2, 3}
	c := []int{3, 2, 1}
	println(getInternalArray(a...) == getInternalArray(b...)) // true
	println(getInternalArray(b...) == getInternalArray(c...)) // false
}
\`\`\`

проигрывает в произволительности на порядок встроенной функции `slices.Equal`:

\`\`\`go
package main

import (
	"slices"
	"testing"
	"unsafe"
)

func getInternalArray[T any](nums ...int) T {
	return *(*T)(unsafe.Pointer(&nums[0]))
}

var (
	a, c []int
)

func init() {
	a = make([]int, 10_000_000)
	c = make([]int, 10_000_000)
	for i := 0; i < 10_000_000; i++ {
		a[i] = i
		c[i] = i
	}
}

func BenchmarkOne(b *testing.B) {
	for i := 0; i < b.N; i++ {
		_ = getInternalArray[[10_000_000]int](a...) == getInternalArray[[10000000]int](c...)
	}
}

func BenchmarkTwo(b *testing.B) {
	for i := 0; i < b.N; i++ {
		slices.Equal(a, c)
	}
}
\`\`\`

\`\`\`
cpu: Intel(R) Core(TM) i5-10400 CPU @ 2.90GHz
BenchmarkOne-12    	      13	  86404167 ns/op	160006320 B/op	       2 allocs/op
BenchmarkTwo-12    	     120	   9667527 ns/op	       0 B/op	       0 allocs/op
\`\`\`

но можно ускориться:

\`\`\`go
package main

import (
	"slices"
	"testing"
	"unsafe"
)

func EqualSlices[T comparable](s1, s2 []int) bool {
	return *(*T)(unsafe.Pointer(&s1[0])) == *(*T)(unsafe.Pointer(&s2[0]))
}

var (
	a, c []int
)

func init() {
	a = make([]int, 10_000_000)
	c = make([]int, 10_000_000)
	for i := 0; i < 10_000_000; i++ {
		a[i] = i
		c[i] = i
	}
}

func BenchmarkOne(b *testing.B) {
	for i := 0; i < b.N; i++ {
		EqualSlices[[10_000_000]int](a, c)
	}
}

func BenchmarkTwo(b *testing.B) {
	for i := 0; i < b.N; i++ {
		slices.Equal(a, c)
	}
}
\`\`\`

\`\`\`
cpu: Intel(R) Core(TM) i5-10400 CPU @ 2.90GHz
BenchmarkOne-12    	     157	   7760157 ns/op	       0 B/op	       0 allocs/op
BenchmarkTwo-12    	     124	  10045822 ns/op	       0 B/op	       0 allocs/op
\`\`\`

```