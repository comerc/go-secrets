#go #golang #mergesort #parallelism #concurrency #algorithms #benchmarking #optimization #goroutines #sync

# Оптимизация параллельной сортировки слиянием в Go

```table-of-contents
```

## Введение

Представленный код на Go реализует три варианта сортировки слиянием: последовательную (`sequentialMergesort`), полностью параллельную (`parallelMergesortV1`) и гибридную (`parallelMergesortV2`). Гибридный подход стремится найти баланс между последовательным и параллельным выполнением, используя константу `max` в качестве порога, определяющего, когда переключаться между ними.  Цель состоит в том, чтобы оптимизировать производительность сортировки, учитывая накладные расходы на создание и синхронизацию горутин.

## Анализ кода

### Последовательная сортировка слиянием (`sequentialMergesort`)

Это классическая рекурсивная реализация сортировки слиянием. Она разбивает входной срез на две половины, рекурсивно сортирует каждую половину, а затем объединяет отсортированные половины.

-   **Шаг 1: Базовый случай.**  Если длина среза меньше или равна 1, он уже отсортирован, и рекурсия завершается.
-   **Шаг 2: Разделение.** Срез делится на две половины.
-   **Шаг 3: Рекурсивная сортировка.**  `sequentialMergesort` вызывается рекурсивно для каждой половины.
-   **Шаг 4: Слияние.**  Функция `merge` объединяет две отсортированные половины.

### Полностью параллельная сортировка слиянием (`parallelMergesortV1`)

Эта версия пытается максимизировать параллелизм, создавая новые горутины для каждой половины на каждом уровне рекурсии.

-   **Шаг 1: Базовый случай.**  Аналогичен последовательной версии.
-   **Шаг 2: Разделение.** Срез делится на две половины.
-   **Шаг 3: Параллельная рекурсивная сортировка.**  Две горутины запускаются с помощью `sync.WaitGroup`, каждая из которых рекурсивно сортирует свою половину среза, вызывая `parallelMergesortV1`.
-   **Шаг 4: Ожидание завершения.**  `wg.Wait()` блокирует выполнение до тех пор, пока обе горутины не завершат свою работу.
-   **Шаг 5: Слияние.**  Функция `merge` объединяет две отсортированные половины.

### Гибридная сортировка слиянием (`parallelMergesortV2`)

Эта версия вводит пороговое значение `max`, чтобы ограничить глубину рекурсии, на которой создаются горутины.  Если размер среза меньше или равен `max`, используется последовательная сортировка.

-   **Шаг 1: Базовый случай.**  Аналогичен последовательной версии.
-   **Шаг 2: Проверка порога.**  Если длина среза меньше или равна `max`, вызывается `sequentialMergesort`.
-   **Шаг 3: Разделение и параллельная рекурсия (если порог превышен).** Если длина среза больше `max`, срез делится на две половины, и запускаются две горутины, как в `parallelMergesortV1`, но вызывающие `parallelMergesortV2`.
-   **Шаг 4: Ожидание завершения.**  `wg.Wait()` блокирует выполнение до завершения горутин.
-   **Шаг 5: Слияние.**  Функция `merge` объединяет две отсортированные половины.

### Функция слияния (`merge`)

Эта функция объединяет два отсортированных подмассива в один отсортированный массив.

-   **Шаг 1: Создание вспомогательных массивов.**  Создаются два временных среза `left` и `right`, содержащие копии левой и правой половин исходного среза.
-   **Шаг 2: Слияние.**  Элементы из `left` и `right` сравниваются и копируются в исходный срез `s` в правильном порядке.
-   **Шаг 3: Копирование оставшихся элементов.**  Если в одном из вспомогательных массивов остались элементы, они копируются в конец `s`.

### Генерация случайного среза (`generateRandomSlice`)

Эта функция создает срез заданной длины, заполненный случайными целыми числами.

-   **Шаг 1: Инициализация генератора случайных чисел.**  `rand.Seed(time.Now().UnixNano())` инициализирует генератор случайных чисел текущим временем, чтобы гарантировать, что при каждом запуске программы генерируются разные последовательности чисел.
-   **Шаг 2: Создание среза.**  Создается срез заданной длины.
-   **Шаг 3: Заполнение случайными числами.**  Цикл `for` заполняет срез случайными числами в диапазоне от 0 до 99.

### Тесты производительности (Benchmarks)

Код включает тесты производительности для сравнения трех вариантов сортировки слиянием.

-   **`BenchmarkParallelMergesortV1` и `BenchmarkParallelMergesortV2`**: измеряют время выполнения параллельной и гибридной версий соответственно.
-  Генерируется случайный срез (`generateRandomSlice`) с длиной `ln` = 1000.
-   Таймер сбрасывается (`b.ResetTimer()`).
-   Цикл `for` выполняет сортировку `b.N` раз. `b.N` автоматически подбирается бенчмарком для получения стабильных результатов.

## Оптимизация и выбор значения `max`

Ключевым моментом в гибридной версии (`parallelMergesortV2`) является выбор оптимального значения для константы `max`.

**Слишком маленькое значение `max`**: Приводит к чрезмерному созданию горутин, что увеличивает накладные расходы на их создание, переключение и синхронизацию.  Это может свести на нет выигрыш от параллелизма, особенно для небольших срезов.

**Слишком большое значение `max`**: Приближает производительность к последовательной версии, уменьшая степень параллелизма и потенциально не используя все доступные ядра процессора.

**Оптимальное значение `max`**: Зависит от нескольких факторов:

1.  **Размер входных данных**: Для очень больших массивов более высокий порог `max` может быть более эффективным, поскольку накладные расходы на горутины становятся менее значительными по сравнению с временем сортировки.
2.  **Количество ядер процессора**: На машинах с большим количеством ядер более низкий порог `max` (больше горутин) может лучше использовать доступные ресурсы.
3.  **Накладные расходы на создание и синхронизацию горутин**: Это зависит от реализации Go и операционной системы.

**Метод подбора оптимального `max`**:

Самый надежный способ – экспериментальный.  Нужно провести серию тестов производительности с разными значениями `max` на целевом оборудовании и с типичными размерами входных данных.  Затем выбрать значение, которое обеспечивает наилучшее среднее время выполнения.  Можно автоматизировать этот процесс, написав скрипт, который запускает тесты с разными значениями `max` и записывает результаты.

## Дополнительные соображения и улучшения

1.  **Динамический `max`**: Вместо фиксированной константы `max` можно рассмотреть возможность динамического определения порога во время выполнения, основываясь на размере входных данных и, возможно, количестве доступных процессоров (с помощью `runtime.NumCPU()`).

2.  **Ограничение количества горутин**: Вместо создания неограниченного числа горутин можно использовать пул горутин фиксированного размера. Это позволит ограничить накладные расходы и избежать потенциального исчерпания ресурсов. [[Пул горутин]]

3.  **Другие алгоритмы сортировки**: Для очень маленьких срезов (значительно меньших, чем текущий `max`) может быть эффективнее использовать более простые алгоритмы сортировки, такие как сортировка вставками, которые имеют меньшие накладные расходы, чем сортировка слиянием.

4. **Использование `sync.Pool`**: В функции `merge` можно использовать `sync.Pool` для переиспользования временных срезов `left` и `right`, чтобы уменьшить количество аллокаций памяти.

5. **Неблокирующие каналы**: Вместо `sync.WaitGroup` можно использовать неблокирующие каналы для передачи данных между горутинами.

Пример использования `sync.Pool`:

```go
var pool = sync.Pool{
	New: func() interface{} {
		return make([]int, 0, 1000) // Начальная емкость буфера
	},
}

func merge(s []int, middle int) {
	left := pool.Get().([]int)
	right := pool.Get().([]int)
	defer pool.Put(left[:0]) // Возвращаем в пул с нулевой длиной, но сохраняем емкость
	defer pool.Put(right[:0])

    left = left[:middle] // устанавливаем длину
    right = right[:len(s)-middle]
	copy(left, s[:middle])
	copy(right, s[middle:])

	i := 0
	j := 0
	k := 0

	for i < len(left) && j < len(right) {
		if left[i] <= right[j] {
			s[k] = left[i]
			i++
		} else {
			s[k] = right[j]
			j++
		}
		k++
	}

	for i < len(left) {
		s[k] = left[i]
		i++
		k++
	}

	for j < len(right) {
		s[k] = right[j]
		j++
		k++
	}
}
```
В этом примере `sync.Pool` хранит пул срезов `[]int`. Функция `merge` получает срезы из пула с помощью `pool.Get()`, использует их, а затем возвращает обратно в пул с помощью `pool.Put()`. Важно сбросить длину срезов до нуля перед возвращением в пул, но сохранить емкость (capacity), чтобы избежать повторных аллокаций.

## Заключение
Представленный код демонстрирует различные подходы к реализации сортировки слиянием в Go, включая последовательную, параллельную и гибридную версии. Гибридный подход (`parallelMergesortV2`) позволяет оптимизировать производительность, комбинируя последовательное и параллельное выполнение в зависимости от размера входных данных и порогового значения `max`. Выбор оптимального значения `max` требует экспериментов на целевом оборудовании. Реализация может быть дополнительно улучшена с помощью динамического определения `max`, ограничения количества горутин, использования `sync.Pool` и других алгоритмов сортировки для небольших срезов.

```old
компромисс между последовательной и параллельной обрбаботкой - требуется подбирать оптимальное значение max для конкретного железа

\`\`\`go
package main_test

import (
	"math/rand"
	"sync"
	"testing"
	"time"
)

func sequentialMergesort(s []int) {
	if len(s) <= 1 {
		return
	}
	middle := len(s) / 2
	sequentialMergesort(s[:middle])
	sequentialMergesort(s[middle:]) // Вторая половина
	merge(s, middle)                // Объединение двух половин
}

func parallelMergesortV1(s []int) {
	if len(s) <= 1 {
		return
	}
	middle := len(s) / 2
	var wg sync.WaitGroup
	wg.Add(2)
	go func() { // Запускается первая половина работы в горутине
		defer wg.Done()
		parallelMergesortV1(s[:middle])
	}()
	go func() { // Запускается вторая половина работы в горутине
		defer wg.Done()
		parallelMergesortV1(s[middle:])
	}()
	wg.Wait()
	merge(s, middle) // Объединение этих половин
}

const max = 100 // Задание величины порога

func parallelMergesortV2(s []int) {
	if len(s) <= 1 {
		return
	}
	if len(s) <= max {
		sequentialMergesort(s) // Вызов последовательной версии
	} else { // Если порог превышен, то выполняется параллельная версия
		middle := len(s) / 2
		var wg sync.WaitGroup
		wg.Add(2)
		go func() {
			defer wg.Done()
			parallelMergesortV2(s[:middle])
		}()
		go func() {
			defer wg.Done()
			parallelMergesortV2(s[middle:])
		}()
		wg.Wait()
		merge(s, middle)
	}
}

func merge(s []int, middle int) {
	left := make([]int, middle)
	right := make([]int, len(s)-middle)

	copy(left, s[:middle])
	copy(right, s[middle:])

	i := 0
	j := 0
	k := 0

	for i < len(left) && j < len(right) {
		if left[i] <= right[j] {
			s[k] = left[i]
			i++
		} else {
			s[k] = right[j]
			j++
		}
		k++
	}

	for i < len(left) {
		s[k] = left[i]
		i++
		k++
	}

	for j < len(right) {
		s[k] = right[j]
		j++
		k++
	}
}

func generateRandomSlice(size int) []int {
	rand.Seed(time.Now().UnixNano())
	slice := make([]int, size)
	for i := range slice {
		slice[i] = rand.Intn(100) // Генерирует случайное число от 0 до 99
	}
	return slice
}

const ln = 1_000

// func BenchmarkSequentialMergesort(b *testing.B) {
// 	s := generateRandomSlice(ln)
// 	b.ResetTimer()
// 	for i := 0; i < b.N; i++ {
// 		sequentialMergesort(s)
// 	}
// }

func BenchmarkParallelMergesortV1(b *testing.B) {
	s := generateRandomSlice(ln)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		parallelMergesortV1(s)
	}
}

func BenchmarkParallelMergesortV2(b *testing.B) {
	s := generateRandomSlice(ln)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		parallelMergesortV2(s)
	}
}
\`\`\`

```