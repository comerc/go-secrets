#profiling #go #pprof #memory #cpu #performance #optimization #debugging #runtime #trace

# Профилирование Go-приложений с помощью pprof

```table-of-contents
```

Рассмотрим задачу профилирования Go-приложений с использованием инструмента `pprof`.  Представленный фрагмент кода демонстрирует базовую настройку для сбора данных о потреблении CPU и памяти. Разберем этот код, объясним принципы работы `pprof`, а также рассмотрим дополнительные возможности и способы анализа собранных данных.

## Разбор предоставленного кода

Предоставленный код на Go подготавливает приложение к профилированию CPU и памяти. Разберем его по частям:

1.  **Импорт необходимых пакетов:**

    ```go
    package main

    import (
    	"os"
    	"runtime"
    	"runtime/pprof"
    )
    ```

    *   `os`: Предоставляет функции для взаимодействия с операционной системой, в данном случае, для создания файлов, в которые будут записываться результаты профилирования.
    *   `runtime`:  Содержит функции для взаимодействия со средой выполнения Go, включая управление сборщиком мусора и доступ к профилировщику.
    *   `runtime/pprof`:  Основной пакет для профилирования, предоставляющий API для сбора и записи данных о производительности.

2.  **Отключение профилирования памяти по умолчанию:**

    ```go
    runtime.MemProfileRate = 0
    ```

    По умолчанию Go собирает информацию о некоторой доле аллокаций памяти.  Установка `MemProfileRate` в 0 отключает сбор этой информации по умолчанию. Это делается для того, чтобы явно включить сбор данных о *всех* аллокациях памяти позже, с помощью `pprof.WriteHeapProfile`.  Это позволяет получить более полную картину использования памяти, но может повлиять на производительность приложения, особенно если оно интенсивно работает с памятью. Значение отличное от нуля включает профилирование памяти с заданной частотой, где значение переменной - количество байт между семплами.

3.  **Запись профиля памяти:**

    ```go
    defer func() {
    	w, _ := os.Create("mem.pb.gz")
    	runtime.GC()
    	_ = pprof.WriteHeapProfile(w)
    	_ = w.Close()
    }()
    ```

    Эта часть кода использует `defer` для выполнения функции в самом конце работы функции `main`, даже в случае паники.  Внутри анонимной функции:

    *   `w, _ := os.Create("mem.pb.gz")`: Создается файл `mem.pb.gz` для записи профиля памяти.  Расширение `.pb.gz` указывает на то, что файл будет содержать данные в формате Protocol Buffers, сжатые с помощью gzip.
    *   `runtime.GC()`:  Явно вызывается сборщик мусора. Это делается для того, чтобы в профиль попали данные об освобожденной памяти.
    *   `_ = pprof.WriteHeapProfile(w)`:  Записывает текущий профиль кучи (heap profile) в файл. Профиль кучи содержит информацию о текущих аллокациях памяти в приложении.
    *   `_ = w.Close()`:  Закрывает файл.

4.  **Запись профиля CPU:**

    ```go
    w, _ := os.Create("cpu.pb.gz")
    _ = pprof.StartCPUProfile(w)
    defer func() {
    	pprof.StopCPUProfile()
    	_ = w.Close()
    }()
    ```

    *   `w, _ := os.Create("cpu.pb.gz")`: Создается файл `cpu.pb.gz` для записи профиля CPU.
    *   `_ = pprof.StartCPUProfile(w)`:  Запускает профилирование CPU.  Профилировщик начинает собирать данные о времени выполнения различных функций в приложении.
    *   `defer func() { ... }()`:  С помощью `defer` гарантируется, что профилирование CPU будет остановлено и файл закрыт в конце работы функции `main`.
    *   `pprof.StopCPUProfile()`:  Останавливает профилирование CPU.
    *   `_ = w.Close()`:  Закрывает файл.

5.  **Основная логика приложения:**

    ```go
    // ...
    ```
    В этом месте (обозначено `// ...`) должна располагаться основная логика приложения, которое мы хотим профилировать.

## Принципы работы pprof

`pprof` – это мощный инструмент для профилирования Go-программ.  Он работает путем сбора данных о различных аспектах работы приложения, таких как:

*   **CPU Profile:**  Показывает, какие функции тратят больше всего процессорного времени.  Это помогает выявить "узкие места" в коде, которые замедляют работу приложения. Профилировщик CPU работает, периодически прерывая выполнение программы и записывая текущий стек вызовов.  Частота прерываний (sampling rate) обычно составляет 100 Гц (100 раз в секунду).
*   **Heap Profile:**  Показывает, какие части программы выделяют больше всего памяти.  Это помогает выявить утечки памяти и оптимизировать использование памяти.  Существует несколько типов профилей кучи:
    *   `inuse_space`:  Показывает объем памяти, выделенной на данный момент.
    *   `alloc_space`:  Показывает общий объем памяти, выделенной с момента запуска приложения (включая освобожденную память).
    *   `inuse_objects`:  Показывает количество объектов, выделенных на данный момент.
    *   `alloc_objects`:  Показывает общее количество объектов, выделенных с момента запуска приложения (включая освобожденные объекты).
*   **Block Profile:**  Показывает, где программа проводит время, ожидая синхронизации примитивов (мьютексы, каналы и т.д.).  Это помогает выявить проблемы с конкурентностью.
*   **Mutex Profile:**  Показывает, где программа проводит время, ожидая захвата мьютексов.  Это более специализированный вид профиля блокировок, который фокусируется только на мьютексах.
*   **Goroutine Profile:**  Показывает текущее состояние всех горутин в приложении.  Это помогает выявить проблемы с управлением горутинами, такие как deadlock'и.
*   **Threadcreate Profile:** Показывает места создания новых потоков операционной системы.
*   **Trace:** Позволяет записывать подробную трассировку выполнения программы, включая события, связанные с горутинами, сетевыми операциями, сборкой мусора и т.д. [[Tracing]].

`pprof` собирает данные в формате Protocol Buffers, который затем можно визуализировать и анализировать с помощью различных инструментов.

## Анализ данных с помощью pprof

После того как вы собрали данные профилирования (файлы `cpu.pb.gz` и `mem.pb.gz` в нашем примере), их можно проанализировать с помощью утилиты `go tool pprof`.

**Основные команды:**

1.  **Интерактивный режим:**

    ```bash
    go tool pprof cpu.pb.gz
    ```

    Эта команда запускает интерактивную оболочку `pprof`, в которой можно выполнять различные команды для анализа профиля.

    *   `top`:  Показывает функции, которые потребляют больше всего ресурсов (CPU, памяти и т.д.).  По умолчанию показывает топ-10.  Можно указать количество выводимых функций, например, `top20`.
    *   `web`:  Генерирует SVG-граф вызовов и открывает его в веб-браузере.  Это очень удобный способ визуализации профиля. Требуется установленный `graphviz`.
    *   `list <function_name>`:  Показывает исходный код указанной функции с аннотациями, показывающими, сколько ресурсов потребляет каждая строка.
    *   `weblist <function_name>`:  То же, что и `list`, но открывает результат в веб-браузере.
    *   `tree`:  Показывает дерево вызовов.
    *   `help`:  Выводит справку по доступным командам.
    * `quit` or `q`: выход.

2.  **Генерация отчетов:**

    `go tool pprof` может генерировать отчеты в различных форматах, таких как:

    *   `text`:  Текстовый отчет (аналогичен выводу команды `top`).
    *   `svg`:  SVG-граф вызовов.
    *   `pdf`:  PDF-отчет.
    *   `png`: PNG.
    *   `gif`: GIF.
    *   `dot`:  Граф в формате DOT (для использования с Graphviz).
    *   `callgrind`:  Отчет в формате Callgrind (для использования с инструментами, такими как KCachegrind).

    Пример:

    ```bash
    go tool pprof -svg cpu.pb.gz > cpu.svg
    ```

    Эта команда сгенерирует SVG-граф вызовов на основе профиля CPU и сохранит его в файл `cpu.svg`.

3. **Сравнение профилей:**

   Можно сравнивать два профиля, чтобы увидеть изменения в производительности между двумя запусками приложения.

    ```bash
    go tool pprof -http=:8080 -diff_base old.pb.gz new.pb.gz
    ```
   Эта команда запустит веб-сервер на порту 8080, который позволит интерактивно сравнивать два профиля.

4.  **Профилирование работающего приложения:**

    `pprof` можно использовать для профилирования уже запущенного приложения, если оно предоставляет HTTP-интерфейс для сбора профилей.  Для этого нужно импортировать пакет `net/http/pprof`:

    ```go
    import _ "net/http/pprof"
    ```

    Это автоматически зарегистрирует обработчики HTTP, которые позволяют получать профили через URL-адреса вида `/debug/pprof/`.  Например, чтобы получить профиль CPU в течение 30 секунд, можно выполнить следующую команду:

    ```bash
    go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30
    ```

    (Предполагается, что приложение слушает порт 6060).

## Дополнительные возможности и примеры

1.  **Указание пути к бинарному файлу:**

    Если вы анализируете профиль, собранный на другой машине, или если `go tool pprof` не может автоматически найти бинарный файл, можно указать путь к нему явно:

    ```bash
    go tool pprof /path/to/your/binary cpu.pb.gz
    ```

2.  **Фильтрация по времени:**

    Если профиль содержит данные за длительный период времени, можно отфильтровать их по времени, используя опции `-seconds`, `-since` и `-until`.

3.  **Использование флагов `-inuse_space`, `-alloc_space`, `-inuse_objects`, `-alloc_objects` для профилей памяти:**

    При анализе профилей памяти можно использовать эти флаги, чтобы указать, какой тип профиля кучи вы хотите анализировать.  Например:

    ```bash
    go tool pprof -inuse_space mem.pb.gz
    ```

4. **Пример профилирования HTTP сервера**

```go
package main

import (
	"fmt"
	"log"
	"net/http"
	_ "net/http/pprof" // подключаем обработчики pprof
	"time"
)

func myHandler(w http.ResponseWriter, r *http.Request) {
	// Имитация нагрузки
	time.Sleep(100 * time.Millisecond)
	fmt.Fprintf(w, "Hello, World!")
}

func main() {
	http.HandleFunc("/", myHandler)
	log.Println("Starting server on :8080")
	log.Fatal(http.ListenAndServe(":8080", nil))
}

```

Запустите этот сервер. Затем в другом терминале можно собрать профиль:
```bash
go tool pprof http://localhost:8080/debug/pprof/profile?seconds=30
```

5. **Профилирование теста**

Go предоставляет возможность профилировать тесты с помощью флагов `-cpuprofile`, `-memprofile`, `-blockprofile`, `-mutexprofile`.
Пример:
```bash
go test -cpuprofile cpu.prof -memprofile mem.prof -bench=.
```
После выполнения тестов, можно проанализировать полученные файлы `cpu.prof` и `mem.prof`.

## Альтернативные решения и инструменты

Хотя `pprof` является стандартным инструментом профилирования Go, существуют и другие инструменты и библиотеки, которые могут быть полезны:

*   **`perf` (Linux):**  Системный профилировщик Linux, который может использоваться для профилирования Go-программ.  Он предоставляет более низкоуровневую информацию, чем `pprof`, и может быть полезен для анализа проблем, связанных с взаимодействием с операционной системой.
*   **`gops`:** Утилита командной строки, которая предоставляет информацию о запущенных Go-процессах, включая возможность получения профилей.
*   **`pyroscope`:**  Инструмент непрерывного профилирования, который позволяет собирать и анализировать профили в реальном времени.
*  **Datadog, New Relic, Prometheus (с экспортером Go):** Мониторинговые системы, которые могут собирать метрики и профили производительности Go-приложений.
* **Jaeger, Zipkin:** Системы распределенной трассировки [[Tracing]].

Выбор инструмента зависит от конкретных потребностей и задач.  `pprof` является хорошим выбором для большинства случаев, но в некоторых ситуациях могут потребоваться более специализированные инструменты.

## Заключение

`pprof` – это мощный и гибкий инструмент для профилирования Go-приложений.  Он позволяет собирать данные о различных аспектах работы приложения, таких как потребление CPU, памяти, блокировки и т.д.  Собранные данные можно анализировать с помощью интерактивной оболочки `pprof` или генерировать отчеты в различных форматах.  `pprof` является стандартным инструментом для профилирования Go и рекомендуется к использованию для выявления и устранения проблем с производительностью.

```old
https://youtu.be/MHn-taXfQ8o?t=3748

\`\`\`go
package main

import (
	"os"
	"runtime"
	"runtime/pprof"
)

func main() {
	runtime.MemProfileRate = 0
	defer func() {
		w, _ := os.Create("mem.pb.gz")
		runtime.GC()
		_ = pprof.WriteHeapProfile(w)
		_ = w.Close()
	}()

	w, _ := os.Create("cpu.pb.gz")
	_ = pprof.StartCPUProfile(w)
	defer func() {
		pprof.StopCPUProfile()
		_ = w.Close()
	}()

	// ...
}
\`\`\`

```