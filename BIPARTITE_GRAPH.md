# Двудольный граф 

## Что такое двудольный граф?

Двудольный (bipartite) граф - это граф, вершины которого можно разделить на **два непересекающихся множества** таким образом, что:
- Каждое ребро соединяет вершину из одного множества с вершиной из другого множества
- Внутри каждого множества нет рёбер между вершинами

## Визуальный пример:

```
Множество A: {1, 3, 5}    Множество B: {2, 4, 6}
     1 ————————— 2
     |           |
     |           |
     4 ————————— 3
     |           |
     |           |
     6 ————————— 5
```

## Эквивалентное определение:

Граф является двудольным **тогда и только тогда**, когда его можно раскрасить в **два цвета** так, что никакие две смежные вершины не имеют одинакового цвета.

## Алгоритм проверки:

1. **Выбираем любую вершину** и красим её в цвет 1
2. **Обходим граф** (BFS или DFS), красим соседей в противоположный цвет
3. **Если встречаем конфликт** (смежные вершины одного цвета) - граф НЕ двудольный
4. **Если обошли весь граф без конфликтов** - граф двудольный

## Пример кода на Go:

```go
func isBipartite(graph map[string][]string) bool {
    color := make(map[string]int)
    
    for start := range graph {
        if color[start] == 0 { // Непосещённая вершина
            if !bfs(graph, start, color) {
                return false
            }
        }
    }
    return true
}

func bfs(graph map[string][]string, start string, color map[string]int) bool {
    queue := []string{start}
    color[start] = 1
    
    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]
        
        for _, neighbor := range graph[node] {
            if color[neighbor] == 0 {
                color[neighbor] = -color[node] // Противоположный цвет
                queue = append(queue, neighbor)
            } else if color[neighbor] == color[node] {
                return false // Конфликт цветов
            }
        }
    }
    return true
}
```

## Практические применения:

- **Планирование расписаний** (студенты/курсы)
- **Сопоставление** (работники/задачи)
- **Сетевые потоки**
- **Задачи о максимальном паросочетании**

Сложность алгоритма: **O(V + E)**, где V - количество вершин, E - количество рёбер.
