```table-of-contents
```
(Установить расширение `Automatic Table Of Contents`)
## Почему Go?

Это матерный язык в мире языков программирования, где простыми выразительными средствами можно сказать больше, чем на родном языке. Плюс gofmt снимает ограничения с выбором редактора.

GoLang == Highload, благодараря встроенному механизму работы в многопроцессорной среде.

- [Дзен Go](https://habr.com/ru/companies/vk/articles/490340/)
- [The Zen of Go](https://the-zen-of-go.netlify.app/)
- [Изучите X за Y минут Где X=Go](https://learnxinyminutes.com/docs/ru-ru/go-ru/)
- [A Tour of Go](https://go.dev/tour/list)
- [Golang | Все Основы за 4 Часа Для Начинающих](https://www.youtube.com/watch?v=h0zxh2TPN_I)
- [Go в примерах](https://gobyexample.com.ru/)
- [Курс Go: онлайн обучение с нуля](https://code-basics.com/ru/languages/go)
- [Курс по изучению Golang для начинающих](https://golangify.com/go/kurs-izucheniya-golang-dlya-nachinayuschih)
- [golang-book.ru](http://golang-book.ru/)
- [Effective Go (RU)](https://github.com/Konstantin8105/Effective_Go_RU)
- [roadmap](https://roadmap.sh/golang)
- [Шпаргалка для собеса по GoLang](https://habr.com/ru/articles/758662/)
- [Практика Go — Основы](https://habr.com/ru/articles/759378/)
- [Практика Go — Concurrency](https://habr.com/ru/articles/759584/)
- [Практика Go — Обработка ошибок (1 часть)](https://habr.com/ru/articles/759840/)
- [Практика Go — Обработка ошибок (2 часть)](https://habr.com/ru/articles/759920/)
- [Планирование в Go: Часть III — Конкурентность](https://habr.com/ru/articles/761606/)
- [Конкурентность — это не параллелизм](https://habr.com/ru/articles/761754/)
- [Ошибки это значения](http://habrahabr.ru/post/269909/)
- [Почему «ошибки это значения» в Go](https://habr.com/ru/articles/270027/)
- [ШБР 2023](https://www.youtube.com/watch?v=SGhdeWlgPTo&list=PLZvfMc-lVSSO2zhyyxQLFmio8NxvQqZoN)
- [Лайфхаки для кода без побочных эффектов: пишем на Go и красиво, и правильно](https://www.youtube.com/watch?v=G-lhh_1XNcI)
- [Оптимизация памяти и управление сборщиком мусора в Go: GOGC и GOMEMLIMIT](https://habr.com/ru/articles/742402/)
- [Go To Memory](https://habr.com/ru/companies/oleg-bunin/articles/676332/)
- [Understanding Real-World Concurrency Bugs in Go](https://songlh.github.io/paper/go-study.pdf)
- [Interfaces in Go](https://go101.org/article/interface.html)
- [Туториал по дженерикам в Go](https://kovardin.ru/articles/go/generics/)
- [DataDog/go-profiler-notes](https://github.com/DataDog/go-profiler-notes)
- [Go Developer Survey 2021 Results](https://go.dev/blog/survey2021-results)
- [Лекции для мидлов в OZON](https://www.youtube.com/@go_developer/videos)

## Code Style

- [What's in a name?](https://go.dev/talks/2014/names.slide)
- [uber-go-guide-ru](https://github.com/sau00/uber-go-guide-ru/blob/master/style.md)
- [Standard Go Project Layout](https://github.com/golang-standards/project-layout)
- [Organizing a Go module](https://go.dev/doc/modules/layout)
- [50 оттенков Go](https://habr.com/ru/companies/vk/articles/314804/)
- [Паттерны проектирования (с картинками)](https://refactoring.guru/ru/design-patterns/go)
- [Паттерны проектирования (с тестами)](https://github.com/AlexanderGrom/go-patterns)
- [Go Clean Architecture](https://github.com/comerc/go-clean-architecture)
- [Communicating sequential processes(CSP) for Go developer in a nutshell](https://levelup.gitconnected.com/communicating-sequential-processes-csp-for-go-developer-in-a-nutshell-866795eb879d)
- [Как не ошибиться с конкурентностью в Go](https://habr.com/ru/companies/avito/articles/466495/)
- [Как избежать применения ORM для Go, используя чистый SQL](https://highload.today/kak-izbezhat-primeneniya-orm-dlya-go-ispolzuya-sql/)
- [Go Concurrency Patterns](https://github.com/lotusirous/go-concurrency-patterns)
- [Go Concurrency Exercises](https://github.com/comerc/go-concurrency-exercises)
- [Как не наступать на грабли в Go](https://habr.com/ru/articles/325468/)
- Web Frameworks: 
	- [Revel](https://github.com/revel/revel) ![](https://img.shields.io/github/stars/revel/revel?style=social) 12.2011 
	- [Gin](https://github.com/gin-gonic/gin) ![](https://img.shields.io/github/stars/gin-gonic/gin?style=social) 06.2014 
	- [Echo](https://github.com/labstack/echo) ![](https://img.shields.io/github/stars/labstack/echo?style=social) 03.2015 
	- [Fiber](https://github.com/gofiber/fiber) ![](https://img.shields.io/github/stars/gofiber/fiber?style=social) 01.2020
- [Тёмные века программного обеспечения](https://github.com/comerc/software_dark_ages/blob/main/TEXT.md)
- [Событийное моделирование традиционных систем](https://github.com/comerc/event_modeling_traditional_systems/blob/main/TEXT.md)
- [Event Modeling Cheat Sheet](https://eventmodeling.org/posts/event-modeling-cheatsheet/)
- [Зачем нужны модульные тесты и как заставить их работать на вас](https://habr.com/ru/articles/767858/)
- [Масштабирование приёмочных тестов](https://habr.com/ru/articles/765996/)
- [Работа без имитаторов](https://habr.com/ru/articles/765956/)
- [Введение в приёмочные тесты](https://habr.com/ru/articles/765892/)
- [Антипаттерны в TDD](https://habr.com/ru/articles/767874/)
- [Idiomatic Go](https://dmitri.shuralyov.com/idiomatic-go)
- [Go Patterns](https://github.com/tmrts/go-patterns)
- [Проблемы функции Golang init](https://habr.com/ru/articles/771858/)
- [Методические рекомендации по написанию Go кода от Uber](https://github.com/sau00/uber-go-guide-ru/blob/master/style.md)
- [Создание атомарных коммитов в Git](https://habr.com/ru/articles/781794/)
- [«Программист-прагматик. Путь от подмастерья к мастеру»: коротко о главном (часть первая)](https://habr.com/ru/companies/productivity_inside/articles/348116/)
- [«Программист-прагматик. Путь от подмастерья к мастеру»: коротко о главном (часть вторая)](https://habr.com/ru/companies/productivity_inside/articles/348932/)
- [Golang design: Generics vs Interfaces, How It Really Works Under the Hood](https://blog.stackademic.com/golang-design-generics-vs-interfaces-how-it-really-works-under-the-hood-c1e5057a7ae6?gi=fa683ee6f9d1)
- [Go Style Decisions](https://google.github.io/styleguide/go/decisions.html)

## Practice

- [go-in-practice](https://github.com/diptomondal007/GoLangBooks/blob/master/go-in-practice.pdf)
- [building-microservices-go](https://github.com/diptomondal007/GoLangBooks/blob/master/building-microservices-go.pdf)
- [go-design-patterns-real-world-projects](https://github.com/diptomondal007/GoLangBooks/blob/master/Go_Design_Patterns_for_Real_World_Projects/go-design-patterns-real-world-projects.pdf)

## Термины

- [0-15) полуинтервал на числовую прямую
- компоратор - функция, которая возвращает -1 || 0 || 1
- ресивер – это объявление типа, для которого вы хотите определить метод.

## Книжки про Алгоритмы

Для изучения оценки сложности алгоритма по "time complexity" & "space complexity" можно начать с книги "Introduction to Algorithms" авторов Кормена, Лейзерсона, Ривеста и Штайна. Это общепризнанная книга по алгоритмам, которая покрывает базовые алгоритмические концепции, включая оценку временной и пространственной сложности. Книга также содержит множество примеров и задач для практического применения.

Или же книжка "[Грокаем алгоритмы](https://t.me/progbook/537)".

Или ещё [Основы алгоритмов - интерактив от Yandex](https://academy.yandex.ru/handbook/algorithms)

Из YouTube: [ВСЯ СЛОЖНОСТЬ АЛГОРИТМОВ ЗА 11 МИНУТ](https://www.youtube.com/watch?v=cXCuXNwzdfY)

[Девять алгоритмов, которые изменили будущее | Джон Маккормик](https://t.me/yaprogrammer/365)

## [/article](./article/) - алгоритмические задачи

- [Как проходят алгоритмические секции на собеседованиях в Яндекс](https://habr.com/ru/companies/yandex/articles/449890/)

### Задача A. Камни и украшения

[[../article/a|Решение]]

> Даны две строки строчных латинских символов: строка J и строка S. Символы, входящие в строку J, — «драгоценности», входящие в строку S — «камни». Нужно определить, какое количество символов из S одновременно являются «драгоценностями». Проще говоря, нужно проверить, какое количество символов из S входит в J.

Это очень простая разминочная задача, к которой прилагаются решения на нескольких языках программирования, чтобы участники могли освоиться с проверяющей системой.

Алгоритм достаточно простой: из строки с «драгоценностями» необходимо построить множество, затем пройтись по строке с «камнями» и каждый символ проверить на вхождение в это множество. Используйте такую реализацию множества, чтобы гарантировать линейную сложность полученного решения, несмотря на то, что входные строки очень короткие и поэтому возможно сдать даже квадратичный по сложности алгоритм.

### Задача B. Последовательно идущие единицы

[[../article/b|Решение]]

> Требуется найти в бинарном векторе самую длинную последовательность единиц и вывести её длину.

Алгоритм решения следующий: пройтись по всем элементам массива; встретив единицу, нужно увеличить счётчик длины текущей последовательности, а, встретив ноль, нужно обнулить этот счётчик. В конце нужно вывести максимальное из значений, которые принимал счётчик.

Проверьте, что правильно обрабатываете ситуацию, когда массив заканчивается на искомую последовательность единиц. При аккуратной реализации такая ситуация не потребует специальной обработки.

Постарайтесь использовать лишь константный объём дополнительной памяти.

### Задача C. Удаление дубликатов

[[../article/c|Решение]]

> Дан упорядоченный по неубыванию массив целых 32-разрядных чисел. Требуется удалить из него все повторения.

Правильный алгоритм последовательно обрабатывает элементы массива, сравнивая их с последним выведенным. Нужно не забыть обновлять переменную, содержащую последний выведенный элемент и, кроме того, не ошибиться при обработке последнего элемента.

При решении этой задачи также не нужно использовать дополнительную память.

### Задача D. Генерация скобочных последовательностей

[[../article/d|Решение]]

> Дано целое число n. Требуется вывести все правильные скобочные последовательности длины 2 \* n, упорядоченные лексикографически (см. https://ru.wikipedia.org/wiki/Лексикографический_порядок). В задаче используются только круглые скобки.

Это пример относительно сложной алгоритмической задачи. Будем генерировать последовательность по одному символу; в каждый момент мы можем к текущей последовательности приписать либо открывающую скобку, либо закрывающую. Открывающую скобку можно дописать, если до этого было добавлено менее n открывающих скобок, а закрывающую — если в текущей последовательности количество открывающих скобок превосходит количество закрывающих. Такой алгоритм при аккуратной реализации автоматически гарантирует лексикографический порядок в ответе; работает за время, пропорциональное произведению количества элементов в ответе на n; при этом требует линейное количество дополнительной памяти.

Примером неэффективного алгоритма был бы следующий: сгенерируем все возможные скобочные последовательности, а затем выведем лишь те из них, что окажутся правильными. При этом объём ответа не позволит решить задачу быстрее, чем тот алгоритм, что приведёт выше.

### Задача E. Анаграммы

[[../article/e|Решение]]

Эта достаточно простая задача — типичный пример задачи, для решения которой необходимо использовать ассоциативные массивы. При решении нужно учитывать, что символы могут повторяться, поэтому необходимо использовать не множества, а словари. Поэтому решение будет следующим: составим из каждой строки по словарю, который для каждого символа будет хранить количество его повторений; затем сравним получившиеся словари. Если они совпадают, необходимо вывести единицу, в противном случае — ноль.

Альтернативное решение: отсортируем входные строки, а затем сравним их. Это решение хуже в том, что оно работает медленнее, а также меняет входные данные. Зато такое решение не использует дополнительной памяти.

Если в процессе собеседования у вас возникло несколько вариантов решения, отличающихся своими по своим характеристикам, расскажите об этом. Всегда здорово, когда разработчик знает несколько вариантов решения задачи и может рассказать об их сильных и слабых сторонах.

### Задача F. Слияние k сортированных списков

[[../article/f|Решение]]

> Даны k отсортированных в порядке неубывания массивов неотрицательных целых чисел, каждое из которых не превосходит 100. Требуется построить результат их слияния: отсортированный в порядке неубывания массив, содержащий все элементы исходных k массивов. Длина каждого массива не превосходит 10 \* k.

Для каждого массива создадим по указателю; изначально каждый указатель расположен в начале соответствующего массива. Элементы, соответствующие позициям указателей, поместим в любую структуру данных, которая поддерживает извлечение минимума — это может быть мультимножество или, например, куча. Далее будем извлекать из этой структуры минимальный элемент, помещать его в ответ, сдвигать позицию указателя в соответствующем массиве и помещать в структуру данных очередной элемент из этого массива.

В этой задаче многие испытывают сложности с форматом ввода. Обратите внимание на то, что первые элементы строк не описывают элементы массивов, они описывают длины массивов!

#### Answer #1:

> В данном коде мы создаем структуру Item, которая содержит значение элемента, номер массива, из которого был взят элемент, и индекс элемента в массиве. Затем мы создаем приоритетную очередь PriorityQueue на основе этой структуры, которая будет использоваться для извлечения минимального элемента.
>
> Далее мы создаем указатели на начало каждого массива и добавляем первые элементы каждого массива в приоритетную очередь. Затем мы начинаем извлекать минимальные элементы из очереди, добавляя их в результирующий массив и сдвигая указатель на соответствующий массив. Если указатель не достиг конца массива, мы добавляем следующий элемент из этого массива в приоритетную очередь.
>
> В итоге мы получаем отсортированный в порядке неубывания массив, содержащий все элементы исходных k массивов. В примере выше мы передаем в функцию mergeArrays три отсортированных массива и получаем отсортированный массив [0 0 3 5 6 6 7 28].

#### Answer #2:

> В этом коде мы используем те же самые структуры данных и алгоритм, что и в предыдущем примере, но более лаконично записываем код. Мы создаем массив pointers для хранения указателей на текущий элемент в каждом массиве, инициализируем его нулями и используем его для проверки достижения конца каждого массива.
>
> Также мы используем оператор append для добавления элементов в результирующий массив, вместо явного указания индекса. Это делает код более читаемым и лаконичным.
>
> В итоге мы получаем тот же отсортированный в порядке неубывания массив, содержащий все элементы исходных k массивов.

#### Answer #3:

> Этот код считывает количество массивов k, затем считывает каждый массив и его элементы, сливает массивы в один отсортированный массив и выводит его элементы. Для слияния массивов используется куча, которая поддерживает извлечение минимума и добавление элементов. Код также содержит функции для построения кучи и поддержания ее свойств.

## [/leetcode](./leetcode/) (ответы)

- [LEETCODE PATTERNS](https://seanprashad.com/leetcode-patterns/)

### linked lists:

- [23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)
- [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)
- [2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)
- [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)

### binary search:

- [704. Binary Search](https://leetcode.com/problems/binary-search/)
- [374. Guess Number Higher or Lower](https://leetcode.com/problems/guess-number-higher-or-lower/)
- [74. Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/)
- [33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)
- [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)
- [81. Search in Rotated Sorted Array II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/)

### hash table:

- [136. Single Number](https://leetcode.com/problems/single-number/) - решить за O(1) по памяти
- [1. Two Sum](https://leetcode.com/problems/two-sum/)
- [18. 4Sum](https://leetcode.com/problems/4sum/)
- [49. Group Anagrams](https://leetcode.com/problems/group-anagrams/)
- [242. Valid Anagram](https://leetcode.com/problems/valid-anagram/)
- [438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/)

### queue/stack:

- [20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)

### dfs/bfs:

- [200. Number of Islands](https://leetcode.com/problems/number-of-islands/)
- [301. Remove Invalid Parentheses](https://leetcode.com/problems/remove-invalid-parentheses/)
- [637. Average of Levels in Binary Tree](https://leetcode.com/problems/average-of-levels-in-binary-tree/)

### sort:

- [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/)

### heap/hash:

- [692. Top K Frequent Words](https://leetcode.com/problems/top-k-frequent-words/)
- [347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)

### two pointers:

- [11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/)
- [763. Partition Labels](https://leetcode.com/problems/partition-labels/)

### sliding window:

- [480. Sliding Window Median](https://leetcode.com/problems/sliding-window-median/)
- [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)
- [424. Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/)

### tree:

- [100. Same Tree](https://leetcode.com/problems/same-tree/)
- [101. Symmetric Tree](https://leetcode.com/problems/symmetric-tree/)
- [110. Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/)
- [113. Path Sum II](https://leetcode.com/problems/path-sum-ii/)

### greedy problems:

- [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)
- [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)
- [714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)
- [309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

## Успеваемость

![performance](/assets/performance.png)
Итого 835 повторов задач, минимум по 20 раз каждую. 🤓 [тынц](https://docs.google.com/spreadsheets/d/1X45zJ7N6ZWw-byRFq0ITaYul07QDJLREMmfhOxsmsdA/edit?usp=sharing)

---

- [coderun.yandex.ru](https://coderun.yandex.ru/)
- [practicum.yandex.ru](https://practicum.yandex.ru/profile/algorithms-interview/)
- [academy.yandex.ru](https://academy.yandex.ru/)
