#golang #pointers #dataTypes #memoryManagement #programming

# Указательные типы данных в Go

```table-of-contents
```

## Что такое указательные типы в Go

Указательные типы в Go - это типы данных, которые содержат ссылку на значение в памяти, а не само значение. Важно понимать, что в Go существует фундаментальное разделение типов на два вида:

1. **Типы-значения (value types)** - передаются по значению (создаётся копия при присваивании или передаче в функцию)
2. **Указательные типы (reference types)** - передаются по ссылке (передаётся ссылка на оригинальное значение)

Указательные типы обычно хранятся в системной куче (heap), хотя компилятор Go может оптимизировать размещение в зависимости от контекста использования. Особенность указательных типов в том, что при их передаче в функции или присваивании другим переменным, функция работает с оригинальными данными, а не с их копиями.

## Встроенные указательные типы в Go

В Go есть несколько встроенных указательных типов:

### [[Срезы (Slices)]]

Срезы представляют собой динамические массивы и являются указателями на последовательность элементов. Структура среза включает:
- указатель на базовый массив
- длину (количество элементов)
- ёмкость (размер выделенного пространства)

```go
// Создание и использование среза
numbers := []int{1, 2, 3, 4, 5}
func modifySlice(s []int) {
    s[0] = 100 // Изменяет оригинальный срез
}
```

### Карты (Maps)

Карты - это хеш-таблицы, реализующие ассоциативные массивы. Они хранят пары ключ-значение и внутренне представлены как указатель на структуру данных хеш-таблицы:

```go
// Создание и использование карты
userAges := map[string]int{
    "Alice": 30,
    "Bob": 25,
}
func increaseAge(m map[string]int, name string) {
    m[name]++ // Изменяет оригинальную карту
}
```

### Каналы (Channels)

Каналы - это коммуникационные механизмы между горутинами, представленные внутренне как указатели:

```go
// Создание и использование канала
ch := make(chan int)
go func() {
    ch <- 42
}()
value := <-ch
```

### Функции (Functions)

Функции в Go являются объектами первого класса и могут быть присвоены переменным, переданы в качестве аргументов и возвращены из других функций:

```go
// Функция как переменная
add := func(a, b int) int {
    return a + b
}
result := add(5, 3)
```

### [[Интерфейсы (Interfaces)]]

Интерфейсы в Go реализованы как пара указателей:
- указатель на таблицу методов
- указатель на конкретное значение

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}

var r Reader = os.Stdin // r содержит указатель на os.Stdin
```

## [[Указатели (Pointers)]]

Явные указатели в Go созданы с помощью оператора `&` и разыменованы с помощью `*`:

```go
x := 10
ptr := &x    // Получение указателя на x
*ptr = 20    // Изменение значения x через указатель
fmt.Println(x) // Выведет 20
```

## Что НЕ является указательным типом

### Структуры (Structs)

Структуры в Go **не являются** указательными типами по умолчанию. Они передаются по значению, что означает копирование всех полей при присваивании или передаче в функцию:

```go
type Person struct {
    Name string
    Age  int
}

func modifyPerson(p Person) {
    p.Age = 30 // Изменяет только локальную копию
}

func modifyPersonPtr(p *Person) {
    p.Age = 30 // Изменяет оригинальную структуру
}
```

Однако, часто используются указатели на структуры, чтобы избежать копирования больших данных:

```go
person := &Person{"Alice", 25} // Указатель на структуру
```

### Строки (Strings)

Строки в Go имеют двойственную природу. Сама строка является неизменяемым (immutable) типом данных, но внутренне она представлена как:
- указатель на массив байтов
- длина

Несмотря на наличие указателя в реализации, строки передаются по значению, но это "неглубокое" копирование - копируется только указатель и длина, а не сами байты данных:

```go
s1 := "hello"
s2 := s1 // Копируется указатель и длина, но не байты
```

## Особенности работы с указательными типами

### Выделение памяти

Указательные типы часто (но не всегда) размещаются в куче (heap):

```go
// Вероятно будет размещен в куче
s := make([]int, 1000000)

// Компилятор может оптимизировать и разместить в стеке
smallSlice := []int{1, 2, 3}
```

### Сборка мусора

Go автоматически освобождает память, занятую указательными типами, когда на них больше нет ссылок:

```go
func temporaryMap() {
    m := make(map[string]int)
    m["temp"] = 100
    // m будет автоматически очищен после выхода из функции
}
```

### Нулевые значения

Нулевые значения для указательных типов:
- Срезы, карты, каналы, функции, интерфейсы: `nil`
- Указатели: `nil`

```go
var s []int       // nil slice
var m map[string]int // nil map
var ch chan int   // nil channel
var f func()      // nil function
var i interface{} // nil interface
var p *int        // nil pointer
```

## Заключение

Понимание различий между указательными типами и типами-значениями в Go критически важно для эффективного программирования. Указательные типы позволяют избежать избыточного копирования данных и обеспечивают возможность изменения оригинальных значений в функциях, но требуют внимательного отношения к управлению памятью и потенциальным проблемам параллельного доступа.


>[!quote] Старая версия
```
	## Указательные типы данных
	
	Указательные типы данных в GoLang - это типы данных, которые хранятся в системной куче (heap) и передаются по указателю, а не по значению. Это означает, что при передаче указательного типа данных в функцию, функция работает с оригинальным объектом, а не с его копией. Некоторые из указательных типов данных в GoLang:
	
	- Срезы (slices) - это динамические массивы, которые представляют собой указатель на последовательность элементов определенного типа.
	- Карты (maps) - это ассоциативные массивы, которые представляют собой указатель на набор пар ключ-значение.
	- Каналы (channels) - это механизм для обмена данными между горутинами (goroutines) в многопоточной программе.
	- Указатели (pointers) - это переменные, которые хранят адрес в памяти другой переменной.
	- ?? Структуры (structs) - это пользовательские типы данных, которые могут содержать поля разных типов.
	- Интерфейсы (interfaces) - это типы данных, которые определяют набор методов, которые должны быть реализованы для типа данных, чтобы он удовлетворял интерфейсу.
	- Функции (functions) - это типы данных, которые могут быть переданы в качестве аргументов другим функциям или возвращены из функций.
	
	Все эти типы данных являются указательными в GoLang и передаются по указателю, а не по значению.
	
	Строки являются неизменяемыми, что означает, что вы не можете изменить строку напрямую, изменяя байты, на которые указывает строка. Хотя строки содержат указатели внутри своей структуры, сами строки не считаются указательными типами данных. Но, поскольку строка, как правило, является указателем, вызов функции для передачи строки не приводит к глубокому копированию байтов. Скопированная строка по-прежнему будет ссылаться на тот же резервный массив.
	
	Поправка:
	
	В GoLang тип данных `struct` является составным типом данных, который объединяет несколько полей разных типов данных в один объект. `struct` не является указательным типом данных, а является значимым типом данных, то есть при передаче `struct` в функцию или присваивании его переменной происходит копирование значений его полей. Однако, при передаче `struct` в функцию в качестве аргумента, происходит передача его копии, что может быть неэффективно для больших `struct`. В таких случаях можно использовать указатели на `struct`.
```

