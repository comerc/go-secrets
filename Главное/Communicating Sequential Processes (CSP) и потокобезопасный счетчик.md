#concurrency #go #CSP #ActorModel #sharedMemory

# Communicating Sequential Processes (CSP) и потокобезопасный счетчик в Go

```table-of-contents
```

## Концепция CSP и Actor Model

Communicating Sequential Processes (CSP) — это формальный язык для описания взаимодействия параллельных систем, разработанный Тони Хоаром. В Go эта модель реализована через горутины и каналы, которые позволяют изолированным процессам (горутинам) взаимодействовать путем обмена сообщениями, а не прямого доступа к общей памяти.

CSP и Actor Model — две разные, но похожие модели конкурентного программирования:

- **CSP**: Процессы взаимодействуют через каналы. Отправитель и получатель должны быть готовы к взаимодействию одновременно (синхронная коммуникация).
- **Actor Model**: Акторы обмениваются сообщениями асинхронно, имеют собственное состояние и могут создавать других акторов.

Основной принцип Go в контексте конкурентности выражен фразой: 
> "Don't communicate by sharing memory, share memory by communicating"

Это означает, что вместо защиты общей памяти с помощью мьютексов и других примитивов синхронизации, лучше организовать обмен данными через каналы.

![](../assets/two_models_of_communucations.png)
![](../assets/blocking_bug_causes.png)
## Проблемы блокировок в параллельных системах

Использование общей памяти часто приводит к проблемам:

1. **[[Состояние гонки (Race Condition)]]** — когда результат зависит от порядка выполнения операций
2. **[[Взаимная блокировка (Deadlock)]]** — когда два или более процессов ожидают друг друга
3. **[[Голодание (Starvation)]]** — когда процесс не получает необходимые ресурсы
4. **[[Живая блокировка (Livelock)]]** — когда процессы активны, но не продвигаются в выполнении

Решение через CSP позволяет избежать многих из этих проблем за счет четкого разделения ответственности и изоляции состояния.

## Реализация потокобезопасного счетчика через CSP

В предложенном решении мы создаем счетчик, который инкрементируется конкурентно с использованием только каналов (без примитивов синхронизации из пакета `sync`, кроме `WaitGroup` для ожидания завершения):

```go
package main

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"sync"
)

type Counter chan int

func NewCounter(ctx context.Context) Counter {
	counter := make(Counter)
	go func() {
		var count int
		for {
			select {
			case v := <-counter:
				count += v
			case counter <- count:
			case <-ctx.Done():
				return
			}
		}
	}()
	return counter
}

func main() {
	ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt)
	defer cancel()
	counter := NewCounter(ctx)
	var wg sync.WaitGroup
	const total = 1_000_000
	wg.Add(total)
	for i := 0; i < total; i++ {
		go func() {
			counter <- 1
			wg.Done()
		}()
	}
	wg.Wait()
	fmt.Println(<-counter)
}
```

## Анализ реализации

Рассмотрим ключевые особенности данной реализации:

1. **Инкапсуляция состояния**: Счетчик инкапсулирует свое состояние (переменную `count`) внутри горутины, и это состояние не доступно напрямую извне.

2. **Взаимодействие через канал**: Тип `Counter` — это просто канал целых чисел. Внешний код взаимодействует со счетчиком, отправляя и получая значения через этот канал.

3. **Мультиплексирование операций**: Конструкция `select` позволяет обрабатывать разные типы операций:
   - Получение значения для инкрементации (`v := <-counter`)
   - Отправка текущего значения счетчика (`counter <- count`)
   - Завершение работы по сигналу контекста (`<-ctx.Done()`)

4. **Обработка сигналов**: Использование `signal.NotifyContext` позволяет корректно завершить работу счетчика при получении сигнала прерывания (Ctrl+C).

5. **Конкурентное инкрементирование**: Миллион горутин параллельно инкрементируют счетчик, отправляя значение 1 в канал.

## Преимущества подхода CSP

1. **Отсутствие гонок данных**: Поскольку доступ к состоянию счетчика осуществляется только из одной горутины, гонки данных исключены.

2. **Простота понимания**: Модель с четким разделением ответственности легче для понимания и отладки.

3. **Масштабируемость**: Такой подход хорошо масштабируется при увеличении числа горутин.

4. **Устойчивость к ошибкам**: Изоляция состояния предотвращает распространение ошибок между компонентами.

## Потенциальные улучшения

Хотя текущая реализация функциональна, можно предложить некоторые улучшения:

1. **Методы для счетчика**: Можно добавить методы для инкрементации и получения значения, чтобы сделать API более понятным:

```go
type Counter struct {
	ch chan int
}

func NewCounter(ctx context.Context) *Counter {
	ch := make(chan int)
	counter := &Counter{ch: ch}
	
	go func() {
		var count int
		for {
			select {
			case v := <-ch:
				count += v
			case ch <- count:
			case <-ctx.Done():
				return
			}
		}
	}()
	
	return counter
}

func (c *Counter) Increment() {
	c.ch <- 1
}

func (c *Counter) Value() int {
	return <-c.ch
}
```

2. **Буферизованный канал**: Для повышения производительности можно использовать буферизованный канал, особенно при большом количестве операций.

3. **Обработка ошибок**: Добавить возможность сообщать об ошибках через отдельный канал или структуру ответа.

## Заключение

Реализация счетчика с использованием принципов CSP демонстрирует элегантный способ обеспечения потокобезопасности без использования примитивов синхронизации. Этот подход полностью соответствует философии Go: "Не общайтесь путем разделения памяти, разделяйте память путем общения".

Такой стиль программирования особенно эффективен в системах с высоким уровнем параллелизма, где традиционные подходы с блокировками могут привести к сложным ошибкам и проблемам производительности.


>[!quote] Старая версия
```
	## Упражнение на "Communicating sequential processes (CSP)" / "Actor Model"
	
	![](./assets/two_models_of_communucations.png)
	![](./assets/blocking_bug_causes.png)
	
	"Don't communicate by sharing memory, share memory by communicating"
	
	Задача: Реализовать структуру-счетчик, которая будет инкрементироваться в конкурентной среде. По завершению программа должна выводить итоговое значение счетчика.
	
	Условие: Без применения примитивов из пакета sync, исключительно используя канал для обеспечения потокобезопасной передачи/приёма данных.
	
	
	### Решение
	
	```go
	package main
	
	import (
		"context"
		"fmt"
		"os"
		"os/signal"
		"sync"
	)
	
	type Counter chan int
	
	func NewCounter(ctx context.Context) Counter {
		counter := make(Counter)
		go func() {
			var count int
			for {
				select {
				case v := <-counter:
					count += v
				case counter <- count:
				case <-ctx.Done():
					return
				}
			}
		}()
		return counter
	}
	
	func main() {
		ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt)
		defer cancel()
		counter := NewCounter(ctx)
		var wg sync.WaitGroup
		const total = 1_000_000
		wg.Add(total)
		for i := 0; i < total; i++ {
			go func() {
				counter <- 1
				wg.Done()
			}()
		}
		wg.Wait()
		fmt.Println(<-counter)
	}
	```
```

