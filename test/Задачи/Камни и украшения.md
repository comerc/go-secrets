#algorithms #go #strings #hashmap #dataStructures

# Задача: Камни и украшения

```table-of-contents
```

## Условие задачи

Даны две строки строчных латинских символов: строка J и строка S. Символы, входящие в строку J, — «драгоценности», входящие в строку S — «камни». Нужно определить, какое количество символов из S одновременно являются «драгоценностями». Другими словами, требуется подсчитать, сколько символов из строки S содержится в строке J.

## Подход к решению

Эта задача является хорошей демонстрацией использования хеш-таблиц (множеств) для эффективного решения алгоритмических задач. Общий алгоритм решения состоит из следующих шагов:

1. Создать множество (хеш-таблицу) из символов строки J (драгоценностей)
2. Пройти по каждому символу строки S (камням)
3. Для каждого символа проверить, содержится ли он в множестве драгоценностей
4. Если символ содержится в множестве, увеличить счетчик
5. Вернуть итоговое значение счетчика

Такой подход обеспечивает линейную временную сложность O(J + S), где J и S — длины соответствующих строк. Пространственная сложность составляет O(J), так как нам нужно хранить множество символов из строки J.

## Реализация на Go

[[a|Камни и украшения]]

Рассмотрим реализацию данного алгоритма на языке Go:

```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strings"
)

func countJewelsInStones(jewels string, stones string) int {
	// Создаем множество драгоценностей
	jewelSet := make(map[rune]bool)
	for _, jewel := range jewels {
		jewelSet[jewel] = true
	}

	// Подсчитываем количество камней, являющихся драгоценностями
	count := 0
	for _, stone := range stones {
		if jewelSet[stone] {
			count++
		}
	}

	return count
}

func main() {
	scanner := bufio.NewScanner(os.Stdin)
	
	// Считываем строку J (драгоценности)
	scanner.Scan()
	jewels := strings.TrimSpace(scanner.Text())
	
	// Считываем строку S (камни)
	scanner.Scan()
	stones := strings.TrimSpace(scanner.Text())
	
	// Вычисляем и выводим результат
	result := countJewelsInStones(jewels, stones)
	fmt.Println(result)
}
```

## Анализ решения

Данное решение имеет следующие характеристики:

1. **Временная сложность**: O(J + S), где J — длина строки драгоценностей, S — длина строки камней. Это достигается благодаря использованию хеш-таблицы, которая обеспечивает константное время операций поиска.

2. **Пространственная сложность**: O(J), так как мы храним каждый символ из строки драгоценностей в хеш-таблице.

Использование хеш-таблицы (в Go — `map`) позволяет достичь линейной сложности, что критически важно для эффективности алгоритма при обработке больших входных данных.

## Альтернативные подходы

Хотя решение с использованием хеш-таблицы наиболее эффективно, рассмотрим несколько альтернативных подходов:

### Использование массива (для ASCII символов)

Если мы знаем, что входные данные ограничены ASCII символами, можно использовать массив для отслеживания драгоценностей:

```go
func countJewelsInStonesArray(jewels string, stones string) int {
	// Создаем массив для отслеживания драгоценностей (ASCII)
	isJewel := [128]bool{}
	for _, jewel := range jewels {
		isJewel[jewel] = true
	}

	count := 0
	for _, stone := range stones {
		if isJewel[stone] {
			count++
		}
	}

	return count
}
```

Этот подход может быть даже быстрее хеш-таблицы для небольших наборов данных из-за меньших накладных расходов.

### Использование битового массива

Для строчных латинских символов (a-z) можно использовать битовый массив, что еще больше оптимизирует использование памяти:

```go
func countJewelsInStonesBitset(jewels string, stones string) int {
	// Битовый массив для строчных латинских букв (a-z)
	var jewelBits uint32

	for _, jewel := range jewels {
		// Устанавливаем соответствующий бит
		jewelBits |= 1 << (jewel - 'a')
	}

	count := 0
	for _, stone := range stones {
		// Проверяем, установлен ли соответствующий бит
		if (jewelBits & (1 << (stone - 'a'))) != 0 {
			count++
		}
	}

	return count
}
```

Однако этот подход работает только если все символы входят в ограниченный диапазон (например, только строчные латинские буквы).

## Заключение

Задача «Камни и украшения» является хорошим примером для демонстрации эффективности использования хеш-таблиц в алгоритмических задачах. Хотя для данной конкретной задачи с короткими входными строками подойдут и менее эффективные алгоритмы, использование хеш-таблицы обеспечивает линейную сложность, что является оптимальным решением.

При работе с подобными задачами важно учитывать ограничения на входные данные и выбирать наиболее подходящую структуру данных, которая обеспечит эффективное решение проблемы.


>[!quote] Старая версия
```
	### Задача A. Камни и украшения
	
> 	Даны две строки строчных латинских символов: строка J и строка S. Символы, входящие в строку J, — «драгоценности», входящие в строку S — «камни». Нужно определить, какое количество символов из S одновременно являются «драгоценностями». Проще говоря, нужно проверить, какое количество символов из S входит в J.
	
	Это очень простая разминочная задача, к которой прилагаются решения на нескольких языках программирования, чтобы участники могли освоиться с проверяющей системой.
	
	Алгоритм достаточно простой: из строки с «драгоценностями» необходимо построить множество, затем пройтись по строке с «камнями» и каждый символ проверить на вхождение в это множество. Используйте такую реализацию множества, чтобы гарантировать линейную сложность полученного решения, несмотря на то, что входные строки очень короткие и поэтому возможно сдать даже квадратичный по сложности алгоритм.
```
