#algorithms #array #duplicates #go #optimization

# Удаление дубликатов в упорядоченном массиве

```table-of-contents
```

## Условие задачи

Дан упорядоченный по неубыванию массив целых 32-разрядных чисел. Требуется удалить из него все повторения, сохраняя порядок оставшихся элементов.

## Алгоритм решения

Для решения этой задачи мы будем использовать подход "двух указателей", который позволит нам эффективно удалить дубликаты без использования дополнительной памяти:

1. Создадим указатель `uniqueIndex`, который будет указывать на позицию, куда нужно записать следующий уникальный элемент
2. Пройдем по массиву, сравнивая текущий элемент с предыдущим уникальным элементом
3. Если текущий элемент отличается от предыдущего уникального, записываем его в позицию `uniqueIndex` и увеличиваем этот указатель
4. После обработки всего массива, `uniqueIndex` будет содержать количество уникальных элементов

Особое внимание следует уделить обработке первого элемента, так как у него нет предыдущего для сравнения.

## Реализация на Go

[[c|Удаление дубликатов]]

```go
package main

import "fmt"

// RemoveDuplicates удаляет дубликаты из упорядоченного массива и возвращает новую длину
func RemoveDuplicates(nums []int) int {
    // Проверка на пустой массив
    if len(nums) == 0 {
        return 0
    }
    
    // Индекс, куда записывать следующий уникальный элемент
    uniqueIndex := 1
    
    // Проходим по массиву, начиная со второго элемента
    for i := 1; i < len(nums); i++ {
        // Если текущий элемент отличается от предыдущего уникального
        if nums[i] != nums[uniqueIndex-1] {
            // Записываем его в позицию uniqueIndex
            nums[uniqueIndex] = nums[i]
            uniqueIndex++
        }
        // Если элемент повторяется, просто пропускаем его
    }
    
    // Возвращаем новую длину массива (количество уникальных элементов)
    return uniqueIndex
}

func main() {
    // Примеры массивов для тестирования
    testCases := [][]int{
        {1, 1, 2, 3, 3, 4, 5, 5, 5},
        {1, 2, 3, 4, 5},
        {1, 1, 1, 1, 1},
        {},
        {7},
    }
    
    for _, nums := range testCases {
        fmt.Printf("Исходный массив: %v\n", nums)
        
        // Создаем копию для сохранения оригинала (только для демонстрации)
        numsCopy := make([]int, len(nums))
        copy(numsCopy, nums)
        
        // Удаляем дубликаты
        newLength := RemoveDuplicates(numsCopy)
        
        fmt.Printf("Массив без дубликатов: %v\n", numsCopy[:newLength])
        fmt.Printf("Новая длина: %d\n\n", newLength)
    }
}
```

## Анализ алгоритма

### Временная сложность

Алгоритм проходит по массиву ровно один раз, выполняя константное количество операций для каждого элемента. Таким образом, временная сложность составляет **O(n)**, где n - размер исходного массива.

### Пространственная сложность

Одно из требований задачи - не использовать дополнительную память. Наш алгоритм модифицирует исходный массив "на месте", используя только константное количество дополнительных переменных (указатели). Поэтому пространственная сложность составляет **O(1)**.

## Ключевые моменты реализации

1. **Обработка первого элемента**: первый элемент всегда считается уникальным, поэтому мы начинаем с `uniqueIndex = 1`.

2. **Сравнение с последним уникальным элементом**: для каждого элемента мы проверяем, отличается ли он от последнего добавленного уникального элемента (который находится в `nums[uniqueIndex-1]`).

3. **Перезапись массива**: мы перезаписываем исходный массив, размещая уникальные элементы в его начале. Это позволяет избежать использования дополнительного массива.

4. **Возврат новой длины**: функция возвращает количество уникальных элементов, что позволяет вызывающему коду работать только с актуальной частью массива.

## Пример пошагового выполнения

Рассмотрим массив `[1, 1, 2, 3, 3, 4, 5, 5, 5]`:

1. Начинаем с `uniqueIndex = 1` (первый элемент уже считается уникальным)
2. `i = 1`: nums[1] = 1, равен nums[0] = 1, пропускаем
3. `i = 2`: nums[2] = 2, не равен nums[0] = 1, записываем в nums[1], увеличиваем uniqueIndex до 2
4. `i = 3`: nums[3] = 3, не равен nums[1] = 2, записываем в nums[2], увеличиваем uniqueIndex до 3
5. `i = 4`: nums[4] = 3, равен nums[2] = 3, пропускаем
6. `i = 5`: nums[5] = 4, не равен nums[2] = 3, записываем в nums[3], увеличиваем uniqueIndex до 4
7. `i = 6`: nums[6] = 5, не равен nums[3] = 4, записываем в nums[4], увеличиваем uniqueIndex до 5
8. `i = 7`: nums[7] = 5, равен nums[4] = 5, пропускаем
9. `i = 8`: nums[8] = 5, равен nums[4] = 5, пропускаем

Итоговый массив: `[1, 2, 3, 4, 5, ...]` с длиной 5.

## Заключение

Данный алгоритм эффективно решает задачу удаления дубликатов из упорядоченного массива без использования дополнительной памяти. Он имеет оптимальную временную сложность O(n) и пространственную сложность O(1), что делает его идеальным решением для поставленной задачи.

Важно отметить, что алгоритм полагается на то, что входной массив уже отсортирован по неубыванию, что позволяет находить дубликаты путем простого сравнения соседних элементов.


>[!quote] Старая версия
```
	### Задача C. Удаление дубликатов
	
> 	Дан упорядоченный по неубыванию массив целых 32-разрядных чисел. Требуется удалить из него все повторения.
	
	Правильный алгоритм последовательно обрабатывает элементы массива, сравнивая их с последним выведенным. Нужно не забыть обновлять переменную, содержащую последний выведенный элемент и, кроме того, не ошибиться при обработке последнего элемента.
	
	При решении этой задачи также не нужно использовать дополнительную память.
```


{Переписать в том числе условие задачи}

