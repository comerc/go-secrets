#dynamicProgramming #algorithms #optimization #memoization #recursion

# Динамическое программирование

```table-of-contents
```

## Что такое динамическое программирование

Динамическое программирование (ДП) представляет собой мощную технику решения сложных задач путём их декомпозиции на более простые подзадачи. Этот метод особенно эффективен для задач с оптимальной подструктурой, где глобально оптимальное решение содержит оптимальные решения подзадач, и с перекрывающимися подзадачами, которые многократно возникают в процессе решения.

В отличие от обычной рекурсии, динамическое программирование позволяет избежать повторных вычислений одних и тех же подзадач, значительно сокращая вычислительную сложность алгоритма. Это достигается за счёт сохранения результатов уже решённых подзадач в специальной структуре данных (обычно массиве или хеш-таблице).

## Ключевые принципы

### Оптимальная подструктура

Задача обладает свойством оптимальной подструктуры, если оптимальное решение задачи содержит в себе оптимальные решения её подзадач. Например, в задаче о кратчайшем пути: если кратчайший путь от A до Z проходит через вершину C, то части пути от A до C и от C до Z также должны быть кратчайшими.

### Перекрывающиеся подзадачи

Алгоритм многократно решает одни и те же подзадачи, вместо того чтобы генерировать новые. Например, при вычислении чисел Фибоначчи рекурсивно, значение F(4) используется как при вычислении F(5), так и при вычислении F(6).

## Подходы к реализации

### Сверху вниз (мемоизация)

Подход "сверху вниз" начинает с исходной задачи и рекурсивно разбивает её на подзадачи. Для предотвращения повторных вычислений используется мемоизация — техника сохранения результатов уже решённых подзадач.

```go
// Пример мемоизации для чисел Фибоначчи
func fibonacci(n int, memo map[int]int) int {
    if val, exists := memo[n]; exists {
        return val
    }
    
    if n <= 1 {
        return n
    }
    
    memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)
    return memo[n]
}

func fib(n int) int {
    memo := make(map[int]int)
    return fibonacci(n, memo)
}
```

### Снизу вверх (табуляция)

Подход "снизу вверх" начинает с решения самых маленьких подзадач и постепенно строит решения для более крупных, используя ранее вычисленные результаты. Этот метод обычно реализуется итеративно, с использованием массива или таблицы для хранения промежуточных результатов.

```go
// Пример табуляции для чисел Фибоначчи
func fibTabulation(n int) int {
    if n <= 1 {
        return n
    }
    
    dp := make([]int, n+1)
    dp[0] = 0
    dp[1] = 1
    
    for i := 2; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    
    return dp[n]
}
```

## Сравнение с другими методами

### Динамическое программирование vs Жадные алгоритмы

Жадные алгоритмы принимают локально оптимальное решение на каждом шаге, надеясь получить глобально оптимальное решение. Они не пересматривают принятые решения и не хранят промежуточные результаты.

Динамическое программирование, напротив, исследует все возможные подзадачи и их комбинации для нахождения действительно оптимального решения. ДП требует хранения результатов подзадач, что увеличивает потребление памяти, но гарантирует оптимальность.

### Динамическое программирование vs Разделяй и властвуй

Оба подхода разбивают задачу на подзадачи, но "разделяй и властвуй" работает с непересекающимися подзадачами, тогда как ДП эффективно при наличии перекрывающихся подзадач.

## Классические задачи динамического программирования

1. **Задача о рюкзаке**: Максимизация ценности предметов, которые можно уместить в рюкзак ограниченной вместимости.

2. **Нахождение наибольшей общей подпоследовательности**: Поиск самой длинной последовательности, которая является подпоследовательностью двух или более последовательностей.

3. **Редакционное расстояние (расстояние Левенштейна)**: Минимальное количество операций для преобразования одной строки в другую.

4. **Задача о разбиении множества**: Разделение набора чисел на две группы с минимальной разницей сумм.

5. **Оптимальное бинарное дерево поиска**: Построение дерева с минимальным ожидаемым временем поиска.

## Оптимизация пространства

Во многих задачах динамического программирования можно оптимизировать использование памяти, сохраняя только необходимые для текущего шага данные. Например, в задаче о числах Фибоначчи достаточно хранить только два последних значения:

```go
func fibOptimized(n int) int {
    if n <= 1 {
        return n
    }
    
    a, b := 0, 1
    for i := 2; i <= n; i++ {
        a, b = b, a+b
    }
    
    return b
}
```

## Практические соображения

1. **Формулировка рекуррентного соотношения**: Ключевой шаг в разработке алгоритма ДП — правильное определение рекуррентного соотношения между состояниями.

2. **Выбор структуры данных**: Для простых задач обычно достаточно массивов, но для более сложных может потребоваться использование хеш-таблиц или многомерных массивов.

3. **Порядок вычислений**: При использовании подхода "снизу вверх" важно правильно определить порядок заполнения таблицы, чтобы все необходимые подзадачи были решены до их использования.

4. **Восстановление решения**: Часто требуется не только значение оптимального решения, но и само решение. Для этого можно хранить дополнительную информацию о выборе, сделанном на каждом шаге.

Динамическое программирование — это мощный инструмент оптимизации, который находит применение в широком спектре задач: от классических алгоритмических проблем до реальных приложений в биоинформатике, компьютерном зрении, распознавании речи и финансовом моделировании.


>[!quote] Старая версия
```
	## Dynamic Programming
	
	Динамическое программирование — способ решения сложных задач путём разбиения их на более простые подзадачи. Он применим к задачам с оптимальной подструктурой, которые выглядят как набор перекрывающихся подзадач, сложность которых чуть меньше исходной. В этом случае время вычислений, по сравнению с «наивными» методами, можно значительно сократить.
	
	Ключевая идея в динамическом программировании достаточно проста. Как правило, чтобы решить поставленную задачу, требуется решить отдельные части задачи (подзадачи), после чего объединить решения подзадач в одно общее решение. Часто многие из этих подзадач одинаковы. Подход динамического программирования состоит в том, чтобы решить каждую подзадачу только один раз, сократив тем самым количество вычислений. Это особенно полезно в случаях, когда число повторяющихся подзадач экспоненциально велико.
	
	Метод динамического программирования сверху — это простое запоминание результатов решения тех подзадач, которые могут повторно встретиться в дальнейшем. Динамическое программирование снизу включает в себя переформулирование сложной задачи в виде рекурсивной последовательности более простых подзадач.
	
	Разница между динамическим программированием и жадными алгоритмами заключается в том, что при динамическом программировании существуют перекрывающиеся подпроблемы, и эти подпроблемы решаются с помощью мемоизации. "Мемоизация" - это техника, при которой решения подпроблем используются для более быстрого решения других подпроблем.
	
	Разница в том, что динамическое программирование требует запоминания ответа для меньших состояний, в то время как жадный алгоритм является локальным в том смысле, что вся необходимая информация находится в текущем состоянии. Конечно, существует некоторое пересечение.
```

